0000              1   ;please work
0000              2   ; do not touch functional except for
0000              3   ; pwm and load_X i think 
0000              4   
0000              5   
0000              6   ;with 5 adc push buttons
0000              7   ;to think about:
0000              8            ;adding another state for when start is pressed so that in forever if it gets sent back to FSM_select
0000              9            ;it will know not to ask for input/go through it
0000             10            ;making the checks into macros
0000             11   
0000             12   ;button functions: rst, next, up, down, start/stop
0000             13   ;display which you're in 
0000             14   ;start-> in the selecting fsm
0000             15   ;stop-> after reset_state in the oven fsm
0000             16   
0000             17   ; 76E003 ADC_Pushbuttons.asm: Reads push buttons using the ADC, AIN0 in P1.7
0000             18   
                 20   $LIST
0000             22   
0000             23   ;  N76E003 pinout:
0000             24   ;                               -------
0000             25   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             26   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             27   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             28   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             29   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             30   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             31   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             32   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             33   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             34   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             35   ;                               -------
0000             36   ;
0000             37   
0000             38   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             39   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             40   TIMER1_RELOAD EQU (0x100-(CLK/(16*BAUD))) ; Need to change timer 1 input divide to 16 in T2MOD
0000             41   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             42   TIMER2_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             43   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             44   
0000             45   
0000             46   ORG 0x0000
0000 020DA5      47            ljmp main
002B             48   ORG 0x002B
002B 020D02      49            ljmp Timer2_ISR
002E             50   
002E             51   ;                     1234567890123456    <- This helps determine the location of the counter
002E 20206865    52   title:            db '  here we go!  ', 0
     72652077
     6520676F
     21202000
003E 20202020    53   blank:            db '                ', 0
     20202020
     20202020
     20202020
     00
004F 53657420    54   swait_message1:   db 'Set your values ', 0   ;s->select fsm, wait->state
     796F7572
     2076616C
     75657320
     00
0060 50726573    55   swait_message2:   db 'Press next      ', 0
     73206E65
     78742020
     20202020
     00
0071 53656C65    56   sstime_message1:  db 'Select soak time', 0   ;s->soak
     63742073
     6F616B20
     74696D65
     00
0082 536F616B    57   sstime_message2:  db 'Soak time:      ', 0
     2074696D
     653A2020
     20202020
     00
0093 53656C65    58   sstemp_message1:  db 'Select soak temp', 0   ;s->soak
     63742073
     6F616B20
     74656D70
     00
00A4 536F616B    59   sstemp_message2:  db 'Soak temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00B5 53656C65    60   srtime_message1:  db 'Select refl time', 0   ;r->reflow
     63742072
     65666C20
     74696D65
     00
00C6 5265666C    61   srtime_message2:  db 'Refl time:      ', 0
     2074696D
     653A2020
     20202020
     00
00D7 53656C65    62   srtemp_message1:  db 'Select refl temp', 0   ;r->reflow
     63742072
     65666C20
     74656D70
     00
00E8 5265666C    63   srtemp_message2:  db 'Refl temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00F9 6D617821    64   too_high_message: db 'max!     ', 0
     20202020
     2000
0103 6D696E21    65   too_low_message:  db 'min!     ', 0
     20202020
     2000
010D 68656C6C    66   forever_message:  db 'hello please', 0
     6F20706C
     65617365
     00
011A 64696500    67   its_works:        db 'die',0
011E 646F6E65    68   done_message:      db 'done!',0
     2100
0124 73746F70    69   stop_message:      db 'stopped!',0
     70656421
     00
012D             70                                               ;1234567890123456
012D 4F76656E    71   oven_fsm_message_0: db 'Oven State 0!   ',0
     20537461
     74652030
     21202020
     00
013E 4F76656E    72   oven_fsm_message_1: db 'Oven State 1!   ',0
     20537461
     74652031
     21202020
     00
014F 4F76656E    73   oven_fsm_message_2: db 'Oven State 2!   ',0
     20537461
     74652032
     21202020
     00
0160 4F76656E    74   oven_fsm_message_3: db 'Oven State 3!   ',0
     20537461
     74652033
     21202020
     00
0171 4F76656E    75   oven_fsm_message_4: db 'Oven State 4!   ',0
     20537461
     74652034
     21202020
     00
0182 4F76656E    76   oven_fsm_message_5: db 'Oven State 5!   ',0
     20537461
     74652035
     21202020
     00
0193             77   ;                                                   1234567890123456
0193 53657474    78   reset_state_message:   db 'Settings Reset! ', 0 ;for testing
     696E6773
     20526573
     65742120
     00
01A4 73746174    79   state1_message:   db 'state1          ', 0 ;for testing
     65312020
     20202020
     20202020
     00
01B5             80   
01B5             81   cseg
01B5             82   ; These 'equ' must match the hardware wiring
01B5             83   LCD_RS equ P1.3
01B5             84   LCD_E  equ P1.4
01B5             85   LCD_D4 equ P0.0
01B5             86   LCD_D5 equ P0.1
01B5             87   LCD_D6 equ P0.2
01B5             88   LCD_D7 equ P0.3
01B5             89   SOUND_OUT equ P1.5
01B5             90   PWM_OUT   EQU P1.0 ; Logic 1=oven on
01B5             91   
                 95   ;Comment bc CrossIDE loves erroring if the last line is empt$LIST
03AA             97   
0000             98   BSEG
0000             99   ; These eight bit variables store the value of the pushbuttons after calling 'ADC_to_PB' below
0000            100   ;PB0: dbit 1 
0000            101   ;PB1: dbit 1     pretty sure left-right is 7-0
0000            102   ;PB2: dbit 1
0000            103   S_S: dbit 1 ;PB3
0001            104   DOWN: dbit 1 ;PB4
0002            105   UP: dbit 1 ;PB5
0003            106   NXT: dbit 1 ;PB6
0004            107   RST: dbit 1 ;PB7
0005            108   mf: dbit 1
0006            109   seconds_flag: dbit 1
0007            110   s_flag: dbit 1 ; set to 1 every time a second has passed
0008            111   oven_flag: dbit 1
0009            112   
0009            113   ;TODO: check if one is enough
0030            114   DSEG at 30H
0030            115   x: ds 4
0034            116   y: ds 4
0038            117   BCD: ds 5
003D            118   selecting_state: ds 1
003E            119   oven_state: ds 1
003F            120   soak_time: ds 1
0040            121   soak_temp: ds 1
0041            122   reflow_time: ds 1
0042            123   reflow_temp: ds 2
0044            124   Count1ms:     ds 2 
0046            125   sec: ds 1
0047            126   temp: ds 1
0048            127   pwm_counter:  ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0049            128   pwm:          ds 1 ; pwm percentage
004A            129   seconds:      ds 1 ; a seconds counter attached to Timer 2 ISR
004B            130   
                574   $LIST
                135   ;commen$LIST
0C57            137   
0C57            138   CSEG
0C57            139   Init_All:
0C57            140            ; Configure all the pins for biderectional I/O
0C57 75AC00     141            mov     P3M1, #0x00
0C5A 75AD00     142            mov     P3M2, #0x00
0C5D 75B300     143            mov     P1M1, #0x00
0C60 75B400     144            mov     P1M2, #0x00
0C63 75B100     145            mov     P0M1, #0x00
0C66 75B200     146            mov     P0M2, #0x00
0C69            147            
0C69            148            ; Could be useful if reset errors !HELP
0C69 79C8       149            mov R1, #200
0C6B 7868       150       mov R0, #104
0C6D D8FE       151       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
0C6F D9FA       152       djnz R1, $-4 ; 25us*200=5.0ms
0C71            153   
0C71 438E10     154            orl     CKCON, #0x10 ; CLK is the input for timer 1
0C74 438780     155            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0C77 759852     156            mov     SCON, #0x52
0C7A 53C4DF     157            anl     T3CON, #0b11011111
0C7D 53890F     158            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0C80 438920     159            orl     TMOD, #0x20 ; Timer 1 Mode 2
0C83 758DF7     160            mov     TH1, #TIMER1_RELOAD
0C86 D28E       161            setb TR1
0C88            162   
0C88            163            ; Using timer 0 for delay functions.  Initialize here:
0C88 C28C       164            clr     TR0 ; Stop timer 0
0C8A 438E08     165            orl     CKCON,#0x08 ; CLK is the input for timer 0
0C8D 5389F0     166            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0C90 438901     167            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0C93            168            
0C93            169            ; Initialize and start the ADC:
0C93            170            
0C93            171            ; AIN0 is connected to P1.7.  Configure P1.7 as input.
0C93 43B380     172            orl     P1M1, #0b10000000
0C96 53B47F     173            anl     P1M2, #0b01111111
0C99            174   
0C99 754900     175            mov pwm, #0
0C9C 754800     176       mov pwm_counter, #0
0C9F            177            
0C9F            178            ; AINDIDS select if some pins are analog inputs or digital I/O:
0C9F 75F600     179            mov AINDIDS, #0x00 ; Disable all analog inputs
0CA2 43F601     180            orl AINDIDS, #0b00000001 ; Using AIN0
0CA5 43E101     181            orl ADCCON1, #0x01 ; Enable ADC
0CA8            182   
0CA8            183            ; timer 2 ?? 
0CA8 120CE0     184            lcall Timer2_Init
0CAB D2AF       185            setb EA
0CAD            186   
0CAD            187            
0CAD 22         188            ret
0CAE            189            
0CAE            190   wait_1ms:
0CAE C28C       191            clr     TR0 ; Stop timer 0
0CB0 C28D       192            clr     TF0 ; Clear overflow flag
0CB2 758CBF     193            mov     TH0, #high(TIMER0_RELOAD_1MS)
0CB5 758A28     194            mov     TL0,#low(TIMER0_RELOAD_1MS)
0CB8 D28C       195            setb TR0
0CBA 308DFD     196            jnb     TF0, $ ; Wait for overflow
0CBD 22         197            ret
0CBE            198   
0CBE            199   ; Wait the number of miliseconds in R2
0CBE            200   waitms:
0CBE 120CAE     201            lcall wait_1ms
0CC1 DAFB       202            djnz R2, waitms
0CC3 22         203            ret
0CC4            204   
0CC4            205   ;set cursor before, also might have to change format     
0CC4            206   Display_formated_BCD:  
0CC4            207       ;Display_BCD(bcd+4) 
0CC4            208       ;Display_BCD(bcd+3) 
0CC4 C000       209            push ar0
0CC6 A83A       209            mov r0, bcd+2
0CC8 120253     209            lcall ?Display_BCD
0CCB D000       209            pop ar0 
0CCD C000       210            push ar0
0CCF A839       210            mov r0, bcd+1
0CD1 120253     210            lcall ?Display_BCD
0CD4 D000       210            pop ar0 
0CD6 C000       211            push ar0
0CD8 A838       211            mov r0, bcd+0
0CDA 120253     211            lcall ?Display_BCD
0CDD D000       211            pop ar0  
0CDF 22         212       ret
0CE0            213   
0CE0            214   Timer2_Init:
0CE0 75C800     215            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0CE3 75CDD7     216            mov TH2, #high(TIMER2_RELOAD)
0CE6 75CC79     217            mov TL2, #low(TIMER2_RELOAD)
0CE9            218            ; Set the reload value
0CE9 75C9A0     219            mov T2MOD, #1010_0000b ; !WIP could be causing timing issue?
0CEC            220            ;orl T2MOD, #0x80 ; Enable timer 2 autoreload this was it before
0CEC 75CBD7     221            mov RCMP2H, #high(TIMER2_RELOAD)
0CEF 75CA79     222            mov RCMP2L, #low(TIMER2_RELOAD)
0CF2            223            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0CF2 E4         224            clr a
0CF3 F544       225            mov Count1ms+0, a
0CF5 F545       226            mov Count1ms+1, a
0CF7 754A00     227            mov seconds, #0
0CFA C206       228            clr seconds_flag
0CFC            229            ; Enable the timer and interrupts
0CFC 439B80     230            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0CFF D2CA       231       setb TR2  ; Enable timer 2
0D01 22         232            ret
0D02            233   ;---------------------------------;
0D02            234   ; ISR for timer 2                 ;
0D02            235   ;---------------------------------;
0D02            236            
0D02            237   Timer2_ISR:
0D02 C2CF       238            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0D04            239            
0D04            240            ; The two registers used in the ISR must be saved in the stack
0D04 C0E0       241            push acc
0D06 C0D0       242            push psw
0D08 C034       243            push y+0
0D0A C035       243            push y+1
0D0C C036       243            push y+2
0D0E C037       243            push y+3
0D10 C030       244            push x+0
0D12 C031       244            push x+1
0D14 C032       244            push x+2
0D16 C033       244            push x+3
0D18            245            
0D18 0548       246       inc pwm_counter
0D1A C3         247            clr c
0D1B E549       248            mov a, pwm
0D1D 9548       249            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0D1F B3         250            cpl c
0D20 9290       251            mov PWM_OUT, c
0D22            252            
0D22 E548       253            mov a, pwm_counter
0D24 B46407     254            cjne a, #100, Timer2_ISR_done
0D27 754800     255            mov pwm_counter, #0
0D2A 054A       256            inc seconds ; It is super easy to keep a seconds count here
0D2C D206       257            setb seconds_flag
0D2E            258      
0D2E            259       ;inc seconds ; It is super easy to keep a seconds count here
0D2E            260   
0D2E            261   
0D2E            262            ;increment second flag 
0D2E            263   
0D2E            264            ;mov a, seconds
0D2E            265            ;add a, #1
0D2E            266            ;da A
0D2E            267            ;mov seconds, A
0D2E            268   
0D2E            269   
0D2E            270   ;Inc_Done:
0D2E            271            ; Check if second has passed
0D2E            272   ;        mov a, Count1ms+0
0D2E            273   ;        cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0D2E            274   ;        mov a, Count1ms+1
0D2E            275   ;        cjne a, #high(1000), Time_increment_done
0D2E            276            
0D2E            277            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0D2E            278   ;        setb seconds_flag ; Let the main program know a second had passed
0D2E            279            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0D2E            280            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0D2E            281   ;        clr a
0D2E            282   ;        mov Count1ms+0, a
0D2E            283   ;        mov Count1ms+1, a
0D2E            284            ; Increment the time only when state flag is on
0D2E            285            ;jnb state, Time_increment_done
0D2E            286            
0D2E            287   ;        mov a, sec
0D2E            288   ;        add a, #0x01
0D2E            289   ;        da a
0D2E            290   ;        mov sec, a
0D2E            291   ;        
0D2E            292   ;        cjne a, #0x60, Time_increment_done
0D2E            293   
0D2E            294                    
0D2E            295   Timer2_ISR_done:
0D2E D033       296            pop x+3
0D30 D032       296            pop x+2
0D32 D031       296            pop x+1
0D34 D030       296            pop x+0
0D36 D037       297            pop y+3
0D38 D036       297            pop y+2
0D3A D035       297            pop y+1
0D3C D034       297            pop y+0
0D3E D0D0       298            pop psw
0D40 D0E0       299            pop acc
0D42 32         300            reti
0D43            301   
0D43            302   
0D43            303   
0D43            304   
0D43            305   
0D43            306   
0D43            307   
0D43            308   ADC_to_PB:
0D43 C0E0       309            push acc
0D45 53E8F0     310            anl ADCCON0, #0xF0
0D48 43E800     311            orl ADCCON0, #0x00 ; Select AIN0
0D4B            312            
0D4B C2EF       313            clr ADCF
0D4D D2EE       314            setb ADCS   ; ADC start trigger signal
0D4F 30EFFD     315       jnb ADCF, $ ; Wait for conversion complete
0D52            316   
0D52 D204       317            setb RST;PB7
0D54 D203       318            setb NXT;PB6
0D56 D202       319            setb UP;PB5
0D58 D201       320            setb DOWN;PB4
0D5A D200       321            setb S_S;PB3
0D5C            322            ;setb PB2
0D5C            323            ;setb PB1
0D5C            324            ;setb PB0
0D5C            325            
0D5C            326            ; Check PB7
0D5C            327   ;ADC_to_PB_L7:
0D5C            328   ;        clr c
0D5C            329   ;        mov a, ADCRH
0D5C            330   ;        subb a, #0xf0
0D5C            331   ;        jc ADC_to_PB_L6
0D5C            332   ;        clr RST;PB7
0D5C            333   ;        ret
0D5C            334   ;
0D5C            335   ;        ; Check PB6
0D5C            336   ;ADC_to_PB_L6:
0D5C            337   ;        clr c
0D5C            338   ;        mov a, ADCRH
0D5C            339   ;        subb a, #0xd0
0D5C            340   ;        jc ADC_to_PB_L5
0D5C            341   ;        clr NXT;PB6
0D5C            342   ;        ret
0D5C            343   
0D5C            344            ; Check PB5
0D5C            345   ADC_to_PB_L5:
0D5C C3         346            clr c
0D5D E5C3       347            mov a, ADCRH
0D5F 94B0       348            subb a, #0xb0
0D61 4005       349            jc ADC_to_PB_L4
0D63 C204       350            clr RST;PB5
0D65 D0E0       351            pop acc
0D67 22         352            ret
0D68            353   
0D68            354            ; Check PB4
0D68            355   ADC_to_PB_L4:
0D68 C3         356            clr c
0D69 E5C3       357            mov a, ADCRH
0D6B 9490       358            subb a, #0x90
0D6D 4005       359            jc ADC_to_PB_L3
0D6F C203       360            clr NXT;PB4
0D71 D0E0       361            pop acc
0D73 22         362            ret
0D74            363   
0D74            364            ; Check PB3
0D74            365   ADC_to_PB_L3:
0D74 C3         366            clr c
0D75 E5C3       367            mov a, ADCRH
0D77 9470       368            subb a, #0x70
0D79 4005       369            jc ADC_to_PB_L2
0D7B C202       370            clr UP;PB3
0D7D D0E0       371            pop acc
0D7F 22         372            ret
0D80            373   
0D80            374            ; Check PB2
0D80            375   ADC_to_PB_L2:
0D80 C3         376            clr c
0D81 E5C3       377            mov a, ADCRH
0D83 9450       378            subb a, #0x50
0D85 4005       379            jc ADC_to_PB_L1
0D87 C201       380            clr DOWN
0D89 D0E0       381            pop acc
0D8B 22         382            ret
0D8C            383   
0D8C            384            ; Check PB1
0D8C            385   ADC_to_PB_L1:
0D8C C3         386            clr c
0D8D E5C3       387            mov a, ADCRH
0D8F 9430       388            subb a, #0x30
0D91 4005       389            jc ADC_to_PB_L0
0D93 C200       390            clr S_S
0D95 D0E0       391            pop acc
0D97 22         392            ret
0D98            393   
0D98            394            ; Check PB0
0D98            395   ADC_to_PB_L0:
0D98 C3         396            clr c
0D99 E5C3       397            mov a, ADCRH
0D9B 9410       398            subb a, #0x10
0D9D 4003       399            jc ADC_to_PB_Done
0D9F            400            ;clr PB0
0D9F D0E0       401            pop acc
0DA1 22         402            ret
0DA2            403            
0DA2            404   ADC_to_PB_Done:
0DA2            405            ; No pusbutton pressed  
0DA2 D0E0       406            pop acc
0DA4 22         407            ret
0DA5            408            
0DA5            409   main:
0DA5 75817F     410            mov sp, #0x7f
0DA8 12061A     411            lcall Temp_Init_All
0DAB 120C57     412            lcall Init_All
0DAE 12020E     413       lcall LCD_4BIT
0DB1            414       
0DB1 120269     415       lcall state_init ;From State_Machine.inc
0DB4            416       
0DB4            417       ; initial messages in LCD
0DB4 C0E0       418            push acc
0DB6 7401       418            mov a, #1
0DB8 14         418            dec a
0DB9 12024E     418            lcall ?Set_Cursor_1 ; Select column and row
0DBC D0E0       418            pop acc
0DBE C083       419            push dph
0DC0 C082       419            push dpl
0DC2 C0E0       419            push acc
0DC4 90002E     419            mov dptr, #Title
0DC7 120241     419            lcall ?Send_Constant_String
0DCA D0E0       419            pop acc
0DCC D082       419            pop dpl
0DCE D083       419            pop dph
0DD0 C0E0       420            push acc
0DD2 7401       420            mov a, #1
0DD4 14         420            dec a
0DD5 12024C     420            lcall ?Set_Cursor_2 ; Select column and row
0DD8 D0E0       420            pop acc
0DDA C083       421            push dph
0DDC C082       421            push dpl
0DDE C0E0       421            push acc
0DE0 90003E     421            mov dptr, #blank
0DE3 120241     421            lcall ?Send_Constant_String
0DE6 D0E0       421            pop acc
0DE8 D082       421            pop dpl
0DEA D083       421            pop dph
0DEC            422   
0DEC 7AFA       423            mov R2, #250
0DEE 120CBE     424            lcall waitms
0DF1            425            
0DF1            426   Forever:
0DF1            427            ; Wait 50 ms between readings
0DF1 7A32       428            mov R2, #50
0DF3 120CBE     429            lcall waitms
0DF6            430   
0DF6            431            ; output? 
0DF6 300604     432            jnb seconds_flag, no_second
0DF9 C206       433            clr seconds_flag
0DFB B295       434            cpl P1.5
0DFD            435   
0DFD            436   no_second:
0DFD            437   
0DFD 7A32       438            mov R2, #50
0DFF 120CBE     439            lcall waitms
0E02            440   
0E02 020E05     441            ljmp FSM_select
0E05            442   
0E05            443            ;Set_Cursor(2, 11)
0E05            444            ;mov r0, #80
0E05            445            ;mov x+0, r0
0E05            446            ;mov x+1, #0 
0E05            447            ;mov x+2, #0
0E05            448            ;mov x+3, #0
0E05            449            ;lcall hex2bcd
0E05            450            ;lcall Display_formated_BCD
0E05            451            
0E05            452            ;check if reaches forever
0E05            453            ;Set_Cursor(1, 1)
0E05            454            ;Send_Constant_String(#forever_message)
0E05            455            ;mov R2, #250
0E05            456            ;lcall waitms
0E05            457            ;ljmp FSM_select
0E05            458   
0E05            459   ;no_second:
0E05            460   ;        ljmp Forever
0E05            461   
0E05            462   ;for testing since there's no other fsm right now
0E05            463   
0E05            464   
0E05            465   ;begin select FSM
0E05            466   FSM_select:
0E05 E53D       467            mov a, selecting_state
0E07            468   
0E07            469   select_wait:
0E07 B4004C     470            cjne a, #0, select_soak_time ;checks the state
0E0A C0E0       471            push acc
0E0C 7401       471            mov a, #1
0E0E 14         471            dec a
0E0F 12024E     471            lcall ?Set_Cursor_1 ; Select column and row
0E12 D0E0       471            pop acc
0E14 C083       472            push dph
0E16 C082       472            push dpl
0E18 C0E0       472            push acc
0E1A 90004F     472            mov dptr, #swait_message1
0E1D 120241     472            lcall ?Send_Constant_String
0E20 D0E0       472            pop acc
0E22 D082       472            pop dpl
0E24 D083       472            pop dph
0E26 C0E0       473            push acc
0E28 7401       473            mov a, #1
0E2A 14         473            dec a
0E2B 12024C     473            lcall ?Set_Cursor_2 ; Select column and row
0E2E D0E0       473            pop acc
0E30 C083       474            push dph
0E32 C082       474            push dpl
0E34 C0E0       474            push acc
0E36 900060     474            mov dptr, #swait_message2
0E39 120241     474            lcall ?Send_Constant_String
0E3C D0E0       474            pop acc
0E3E D082       474            pop dpl
0E40 D083       474            pop dph
0E42 7AFA       475            mov R2, #250
0E44 120CBE     476            lcall waitms
0E47            477       ;lcall ADC_to_PB ;checks for button press
0E47 121065     478       lcall rst_check
0E4A 121070     479       lcall nxt_check
0E4D 121133     480       lcall s_s_check
0E50 020DF1     481       ljmp forever ;i believe 
0E53            482   
0E53            483   select_soak_temp_ah:
0E53 020EDB     484            ljmp select_soak_temp
0E56            485   
0E56            486   select_soak_time:
0E56 B401FA     487            cjne a, #1, select_soak_temp_ah ;checks the state
0E59 C0E0       488            push acc
0E5B 7401       488            mov a, #1
0E5D 14         488            dec a
0E5E 12024E     488            lcall ?Set_Cursor_1 ; Select column and row
0E61 D0E0       488            pop acc
0E63 C083       489            push dph
0E65 C082       489            push dpl
0E67 C0E0       489            push acc
0E69 900071     489            mov dptr, #sstime_message1
0E6C 120241     489            lcall ?Send_Constant_String
0E6F D0E0       489            pop acc
0E71 D082       489            pop dpl
0E73 D083       489            pop dph
0E75 C0E0       490            push acc
0E77 7401       490            mov a, #1
0E79 14         490            dec a
0E7A 12024C     490            lcall ?Set_Cursor_2 ; Select column and row
0E7D D0E0       490            pop acc
0E7F C083       491            push dph
0E81 C082       491            push dpl
0E83 C0E0       491            push acc
0E85 900082     491            mov dptr, #sstime_message2
0E88 120241     491            lcall ?Send_Constant_String
0E8B D0E0       491            pop acc
0E8D D082       491            pop dpl
0E8F D083       491            pop dph
0E91            492       ;Set_Cursor(2, 11)
0E91 C005       493       push AR5  ;display the current soak_time
0E93 AD30       494       mov R5, x
0E95 853F30     495       mov x+0, soak_time
0E98 753100     496            mov x+1, #0
0E9B 753200     497            mov x+2, #0
0E9E 753300     498            mov x+3, #0
0EA1 C0E0       499            push acc
0EA3 740B       499            mov a, #11
0EA5 14         499            dec a
0EA6 12024C     499            lcall ?Set_Cursor_2 ; Select column and row
0EA9 D0E0       499            pop acc
0EAB            500            ;Send_Constant_String(#its_works)
0EAB 1203AA     501       lcall hex2bcd
0EAE 120CC4     502       lcall Display_formated_BCD
0EB1 8D30       503       mov x, R5
0EB3 D005       504       pop AR5
0EB5            505       ;lcall ADC_to_PB ;checks for button press
0EB5 121065     506       lcall rst_check
0EB8 C003       507       push AR3 ;set the paramaters for up/down
0EBA C004       508       push AR4
0EBC C005       509       push AR5
0EBE 7B3C       510       mov R3, #0x3C ;min value allowed for soak time !check it please
0EC0 7C78       511       mov R4, #0x78 ;120  ;max value, !check it please, also is the dec? hex?
0EC2 AD3F       512       mov R5, soak_time
0EC4 1210A3     513       lcall up_check
0EC7 1210EB     514       lcall down_check
0ECA 8D3F       515       mov soak_time, R5
0ECC D005       516       pop AR5
0ECE D004       517       pop AR4
0ED0 D003       518       pop AR3  ;am i doing this right?
0ED2 121133     519       lcall s_s_check
0ED5 121070     520       lcall nxt_check
0ED8 020DF1     521       ljmp forever ;i believe 
0EDB            522   
0EDB            523   select_soak_temp:
0EDB B40203     524            cjne a, #2, $+6 ;checks the state
0EDE 020EE4     525            ljmp $+6
0EE1 020F70     526            ljmp select_reflow_time
0EE4 C0E0       527            push acc
0EE6 7401       527            mov a, #1
0EE8 14         527            dec a
0EE9 12024E     527            lcall ?Set_Cursor_1 ; Select column and row
0EEC D0E0       527            pop acc
0EEE C083       528            push dph
0EF0 C082       528            push dpl
0EF2 C0E0       528            push acc
0EF4 900093     528            mov dptr, #sstemp_message1
0EF7 120241     528            lcall ?Send_Constant_String
0EFA D0E0       528            pop acc
0EFC D082       528            pop dpl
0EFE D083       528            pop dph
0F00 C0E0       529            push acc
0F02 7401       529            mov a, #1
0F04 14         529            dec a
0F05 12024C     529            lcall ?Set_Cursor_2 ; Select column and row
0F08 D0E0       529            pop acc
0F0A C083       530            push dph
0F0C C082       530            push dpl
0F0E C0E0       530            push acc
0F10 9000A4     530            mov dptr, #sstemp_message2
0F13 120241     530            lcall ?Send_Constant_String
0F16 D0E0       530            pop acc
0F18 D082       530            pop dpl
0F1A D083       530            pop dph
0F1C C0E0       531            push acc
0F1E 740B       531            mov a, #11
0F20 14         531            dec a
0F21 12024C     531            lcall ?Set_Cursor_2 ; Select column and row
0F24 D0E0       531            pop acc
0F26 C005       532       push AR5  ;display current soak temp
0F28 C030       533            push x+0
0F2A C031       533            push x+1
0F2C C032       533            push x+2
0F2E C033       533            push x+3
0F30 854030     534            mov x+0, soak_temp
0F33 753100     535            mov x+1, #0
0F36 753200     536            mov x+2, #0
0F39 753300     537            mov x+3, #0
0F3C 1203AA     538       lcall hex2bcd
0F3F 120CC4     539       lcall Display_formated_BCD
0F42            540       ;mov x, R5
0F42 D033       541            pop x+3
0F44 D032       541            pop x+2
0F46 D031       541            pop x+1
0F48 D030       541            pop x+0
0F4A            542       ;lcall ADC_to_PB ;checks for button press
0F4A 121065     543       lcall rst_check
0F4D C003       544       push AR3 ;set the paramaters for up/down
0F4F C004       545       push AR4
0F51 C005       546       push AR5
0F53 7B96       547       mov R3, #0x96 ;min value allowed !check it please (150 decimal)
0F55 7CC8       548       mov R4, #0xC8 ;max value, !check it please, also is the dec? hex? (200 decimal)
0F57 AD40       549       mov R5, soak_temp
0F59 1210A3     550       lcall up_check
0F5C 1210EB     551       lcall down_check
0F5F 8D40       552       mov soak_temp, R5
0F61 D005       553       pop AR5
0F63 D004       554       pop AR4
0F65 D003       555       pop AR3  ;am i doing this right?
0F67 121133     556       lcall s_s_check
0F6A 121070     557       lcall nxt_check
0F6D 020DF1     558       ljmp forever ;i believe 
0F70            559   
0F70            560   select_reflow_time:
0F70 B40379     561            cjne a, #3, select_reflow_temp ;checks the state
0F73 C0E0       562            push acc
0F75 7401       562            mov a, #1
0F77 14         562            dec a
0F78 12024E     562            lcall ?Set_Cursor_1 ; Select column and row
0F7B D0E0       562            pop acc
0F7D C083       563            push dph
0F7F C082       563            push dpl
0F81 C0E0       563            push acc
0F83 9000B5     563            mov dptr, #srtime_message1
0F86 120241     563            lcall ?Send_Constant_String
0F89 D0E0       563            pop acc
0F8B D082       563            pop dpl
0F8D D083       563            pop dph
0F8F C0E0       564            push acc
0F91 7401       564            mov a, #1
0F93 14         564            dec a
0F94 12024C     564            lcall ?Set_Cursor_2 ; Select column and row
0F97 D0E0       564            pop acc
0F99 C083       565            push dph
0F9B C082       565            push dpl
0F9D C0E0       565            push acc
0F9F 9000C6     565            mov dptr, #srtime_message2
0FA2 120241     565            lcall ?Send_Constant_String
0FA5 D0E0       565            pop acc
0FA7 D082       565            pop dpl
0FA9 D083       565            pop dph
0FAB C0E0       566            push acc
0FAD 740B       566            mov a, #11
0FAF 14         566            dec a
0FB0 12024C     566            lcall ?Set_Cursor_2 ; Select column and row
0FB3 D0E0       566            pop acc
0FB5 C005       567       push AR5  ;display current reflow time
0FB7 AD30       568       mov R5, x
0FB9 854130     569       mov x, reflow_time
0FBC 1203AA     570       lcall hex2bcd
0FBF 120CC4     571       lcall Display_formated_BCD
0FC2 8D30       572       mov x, R5
0FC4 D005       573       pop AR5
0FC6            574       ;lcall ADC_to_PB ;checks for button press
0FC6 121065     575       lcall rst_check
0FC9 C003       576       push AR3 ;set the paramaters for up/down
0FCB C004       577       push AR4
0FCD C005       578       push AR5
0FCF 7B00       579       mov R3, #0x00 ;45 min value allowed !check it please
0FD1 7C2D       580       mov R4, #0x2D ;75 max value, !check it please, also is the dec? hex?
0FD3 AD41       581       mov R5, reflow_time
0FD5 1210A3     582       lcall up_check
0FD8 1210EB     583       lcall down_check
0FDB 8D41       584       mov reflow_time, R5
0FDD D005       585       pop AR5
0FDF D004       586       pop AR4
0FE1 D003       587       pop AR3  ;am i doing this right?
0FE3 121133     588       lcall s_s_check
0FE6 121070     589       lcall nxt_check
0FE9 020DF1     590       ljmp forever ;i believe 
0FEC            591   
0FEC            592   select_reflow_temp:
0FEC            593            ;shouldn't need to check the state
0FEC C0E0       594            push acc
0FEE 7401       594            mov a, #1
0FF0 14         594            dec a
0FF1 12024E     594            lcall ?Set_Cursor_1 ; Select column and row
0FF4 D0E0       594            pop acc
0FF6 C083       595            push dph
0FF8 C082       595            push dpl
0FFA C0E0       595            push acc
0FFC 9000D7     595            mov dptr, #srtemp_message1
0FFF 120241     595            lcall ?Send_Constant_String
1002 D0E0       595            pop acc
1004 D082       595            pop dpl
1006 D083       595            pop dph
1008 C0E0       596            push acc
100A 7401       596            mov a, #1
100C 14         596            dec a
100D 12024C     596            lcall ?Set_Cursor_2 ; Select column and row
1010 D0E0       596            pop acc
1012 C083       597            push dph
1014 C082       597            push dpl
1016 C0E0       597            push acc
1018 9000E8     597            mov dptr, #srtemp_message2
101B 120241     597            lcall ?Send_Constant_String
101E D0E0       597            pop acc
1020 D082       597            pop dpl
1022 D083       597            pop dph
1024 C0E0       598            push acc
1026 740B       598            mov a, #11
1028 14         598            dec a
1029 12024C     598            lcall ?Set_Cursor_2 ; Select column and row
102C D0E0       598            pop acc
102E C005       599       push AR5  ;display current reflow temp
1030 AD30       600       mov R5, x
1032 854230     601       mov x, reflow_temp
1035 1203AA     602       lcall hex2bcd
1038 120CC4     603       lcall Display_formated_BCD
103B 8D30       604       mov x, R5
103D D005       605       pop AR5
103F            606       ;lcall ADC_to_PB ;checks for button press
103F 121065     607       lcall rst_check
1042 C003       608       push AR3  ;set the paramaters for up/down
1044 C004       609       push AR4
1046 C005       610       push AR5
1048 7BD9       611       mov R3, #0xD9 ;217 DEC ;min value allowed !check it please
104A 7CF0       612       mov R4, #0xF0 ; 255 DEC ;max value, !check it please, also is the dec? hex?
104C AD42       613       mov R5, reflow_temp
104E 1210A3     614       lcall up_check
1051 1210EB     615       lcall down_check
1054 8D42       616       mov reflow_temp, R5
1056 D005       617       pop AR5
1058 D004       618       pop AR4
105A D003       619       pop AR3  ;am i doing this right?
105C 121133     620       lcall s_s_check
105F 121070     621       lcall nxt_check
1062 020DF1     622       ljmp forever ;i believe 
1065            623   
1065            624   ;maybe make these macros :(
1065            625   ;use R3 & R4 & R5 as parameters
1065            626   rst_check:
1065 120D43     627            lcall ADC_to_PB
1068 A204       628            mov c, RST
106A 5001       629       jnc rst_check_0 ;!could be jc
106C 22         630       ret
106D            631   rst_check_0:
106D 020279     632       ljmp reset_state ;or whatever it's called, wait state of oven fsm
1070            633   
1070            634   nxt_check:
1070 120D43     635            lcall ADC_to_PB
1073 A203       636            mov c, NXT
1075 5001       637       jnc next_check_1 
1077 22         638            ret
1078            639   next_check_1: 
1078            640       ;load_x(selecting_state)
1078            641       ;load_y(4)
1078 853D30     642            mov x, selecting_state
107B 753100     643            mov x+1, #0
107E 753200     644            mov x+2, #0
1081 753300     645            mov x+3, #0
1084 753404     646            mov y, #0x04
1087 753500     647            mov y+1, #0
108A 753600     648            mov y+2, #0
108D 753700     649            mov y+3, #0
1090 1204EA     650       lcall x_eq_y
1093 D3         651            setb c
1094 200507     652            jb mf, next_check_2
1097 E53D       653       mov a, selecting_state 
1099 3400       654       addc a, #0 ;uh
109B F53D       655       mov selecting_state, a
109D 22         656       ret
109E            657   next_check_2:
109E C3         658            clr c
109F 753D00     659            mov selecting_state, #0 ;can't go above 4 (there are 5 states)
10A2            660   
10A2 22         661            ret
10A3            662   
10A3            663   up_check: ;R4 max
10A3 120D43     664            lcall ADC_to_PB
10A6 A202       665            mov c, UP
10A8 5001       666            jnc up_check_1
10AA 22         667            ret 
10AB            668   up_check_1:
10AB 8C30       669            mov x, R4
10AD 753100     670            mov x+1, #0
10B0 753200     671            mov x+2, #0
10B3 753300     672            mov x+3, #0
10B6 8D34       673            mov y, R5
10B8 753500     674            mov y+1, #0
10BB 753600     675            mov y+2, #0
10BE 753700     676            mov y+3, #0
10C1 1204CE     677            lcall x_gt_y ;max > value
10C4 D3         678            setb c
10C5 300505     679            jnb mf, up_check_2
10C8 ED         680            mov a, R5
10C9 3400       681            addc a, #0 ;dec? hex?
10CB FD         682            mov R5, a
10CC 22         683            ret
10CD            684   up_check_2:
10CD C3         685            clr c
10CE C0E0       686            push acc
10D0 740B       686            mov a, #11
10D2 14         686            dec a
10D3 12024C     686            lcall ?Set_Cursor_2 ; Select column and row
10D6 D0E0       686            pop acc
10D8 C083       687            push dph
10DA C082       687            push dpl
10DC C0E0       687            push acc
10DE 9000F9     687            mov dptr, #too_high_message
10E1 120241     687            lcall ?Send_Constant_String
10E4 D0E0       687            pop acc
10E6 D082       687            pop dpl
10E8 D083       687            pop dph
10EA 22         688            ret
10EB            689   
10EB            690   down_check: ;R3 min
10EB 120D43     691            lcall ADC_to_PB
10EE A201       692            mov c, DOWN
10F0 5001       693            jnc down_check_1
10F2 22         694            ret
10F3            695   down_check_1:
10F3 8B30       696            mov x, R3
10F5 753100     697            mov x+1, #0
10F8 753200     698            mov x+2, #0
10FB 753300     699            mov x+3, #0
10FE 8D34       700            mov y, R5
1100 753500     701            mov y+1, #0
1103 753600     702            mov y+2, #0
1106 753700     703            mov y+3, #0
1109 1204B2     704            lcall x_lt_y ;min < value
110C D3         705            setb c
110D 300505     706            jnb mf, down_check_2
1110 ED         707            mov a, R5
1111 9400       708            subb a, #0 ;dec? hex?
1113 FD         709            mov R5, a
1114 22         710            ret
1115            711   down_check_2:
1115 C3         712            clr c
1116 C0E0       713            push acc
1118 740B       713            mov a, #11
111A 14         713            dec a
111B 12024C     713            lcall ?Set_Cursor_2 ; Select column and row
111E D0E0       713            pop acc
1120 C083       714            push dph
1122 C082       714            push dpl
1124 C0E0       714            push acc
1126 900103     714            mov dptr, #too_low_message
1129 120241     714            lcall ?Send_Constant_String
112C D0E0       714            pop acc
112E D082       714            pop dpl
1130 D083       714            pop dph
1132 22         715            ret
1133            716   
1133            717   s_s_check:
1133 120D43     718            lcall ADC_to_PB
1136 A200       719            mov c, S_S
1138 5001       720            jnc s_s_check_done ;!could be jb
113A 22         721            ret
113B            722   s_s_check_done:
113B 02084F     723            ljmp FSM_Init ;or whatever it's called, 1st state of oven FSM
113E            724   
113E            725   END
