0000              1   ;please work
0000              2   ; do not touch functional except for
0000              3   ; pwm and load_X i think 
0000              4   
0000              5   
0000              6   ;with 5 adc push buttons
0000              7   ;to think about:
0000              8            ;adding another state for when start is pressed so that in forever if it gets sent back to FSM_select
0000              9            ;it will know not to ask for input/go through it
0000             10            ;making the checks into macros
0000             11   
0000             12   ;button functions: rst, next, up, down, start/stop
0000             13   ;display which you're in 
0000             14   ;start-> in the selecting fsm
0000             15   ;stop-> after reset_state in the oven fsm
0000             16   
0000             17   ; 76E003 ADC_Pushbuttons.asm: Reads push buttons using the ADC, AIN0 in P1.7
0000             18   
                 20   $LIST
0000             22   
0000             23   ;  N76E003 pinout:
0000             24   ;                               -------
0000             25   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             26   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             27   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             28   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             29   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             30   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             31   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             32   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             33   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             34   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             35   ;                               -------
0000             36   ;
0000             37   
0000             38   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             39   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             40   TIMER1_RELOAD EQU (0x100-(CLK/(16*BAUD))) ; Need to change timer 1 input divide to 16 in T2MOD
0000             41   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             42   TIMER2_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             43   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             44   
0000             45   
0000             46   ORG 0x0000
0000 020CD1      47            ljmp main
002B             48   ORG 0x002B
002B 020C2E      49            ljmp Timer2_ISR
002E             50   
002E             51   ;                     1234567890123456    <- This helps determine the location of the counter
002E 20206865    52   title:            db '  here we go!  ', 0
     72652077
     6520676F
     21202000
003E 20202020    53   blank:            db '                ', 0
     20202020
     20202020
     20202020
     00
004F 53657420    54   swait_message1:   db 'Set your values ', 0   ;s->select fsm, wait->state
     796F7572
     2076616C
     75657320
     00
0060 50726573    55   swait_message2:   db 'Press next      ', 0
     73206E65
     78742020
     20202020
     00
0071 53656C65    56   sstime_message1:  db 'Select soak time', 0   ;s->soak
     63742073
     6F616B20
     74696D65
     00
0082 536F616B    57   sstime_message2:  db 'Soak time:      ', 0
     2074696D
     653A2020
     20202020
     00
0093 53656C65    58   sstemp_message1:  db 'Select soak temp', 0   ;s->soak
     63742073
     6F616B20
     74656D70
     00
00A4 536F616B    59   sstemp_message2:  db 'Soak temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00B5 53656C65    60   srtime_message1:  db 'Select refl time', 0   ;r->reflow
     63742072
     65666C20
     74696D65
     00
00C6 5265666C    61   srtime_message2:  db 'Refl time:      ', 0
     2074696D
     653A2020
     20202020
     00
00D7 53656C65    62   srtemp_message1:  db 'Select refl temp', 0   ;r->reflow
     63742072
     65666C20
     74656D70
     00
00E8 5265666C    63   srtemp_message2:  db 'Refl temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00F9 6D617821    64   too_high_message: db 'max!     ', 0
     20202020
     2000
0103 6D696E21    65   too_low_message:  db 'min!     ', 0
     20202020
     2000
010D 68656C6C    66   forever_message:  db 'hello please', 0
     6F20706C
     65617365
     00
011A 64696500    67   its_works:        db 'die',0
011E 646F6E65    68   done_message:      db 'done!',0
     2100
0124 73746F70    69   stop_message:      db 'stopped!',0
     70656421
     00
012D             70                                               ;1234567890123456
012D 52616D70    71   oven_fsm_message_0: db 'Ramp to Soak!   ',0
     20746F20
     536F616B
     21202020
     00
013E 536F616B    72   oven_fsm_message_1: db 'Soak State!   ',0
     20537461
     74652120
     202000
014D 52616D70    73   oven_fsm_message_2: db 'Ramp to Peak!   ',0
     20746F20
     5065616B
     21202020
     00
015E 5265666C    74   oven_fsm_message_3: db 'Reflow!   ',0
     6F772120
     202000
0169 436F6F6C    75   oven_fsm_message_4: db 'Cooldown!   ',0
     646F776E
     21202020
     00
0176 596F7520    76   oven_fsm_message_5: db 'You did it!   ',0
     64696420
     69742120
     202000
0185             77   ;                                                   1234567890123456
0185 53657474    78   reset_state_message:   db 'Settings Reset! ', 0 ;for testing
     696E6773
     20526573
     65742120
     00
0196 73746174    79   state1_message:   db 'state1          ', 0 ;for testing
     65312020
     20202020
     20202020
     00
01A7             80   
01A7             81   cseg
01A7             82   ; These 'equ' must match the hardware wiring
01A7             83   LCD_RS equ P1.3
01A7             84   LCD_E  equ P1.4
01A7             85   LCD_D4 equ P0.0
01A7             86   LCD_D5 equ P0.1
01A7             87   LCD_D6 equ P0.2
01A7             88   LCD_D7 equ P0.3
01A7             89   SOUND_OUT equ P1.5
01A7             90   PWM_OUT   EQU P1.0 ; Logic 1=oven on
01A7             91   
                 95   ;Comment bc CrossIDE loves erroring if the last line is empt$LIST
03A6             97   
0000             98   BSEG
0000             99   ; These eight bit variables store the value of the pushbuttons after calling 'ADC_to_PB' below
0000            100   ;PB0: dbit 1 
0000            101   ;PB1: dbit 1     pretty sure left-right is 7-0
0000            102   ;PB2: dbit 1
0000            103   S_S: dbit 1 ;PB3
0001            104   DOWN: dbit 1 ;PB4
0002            105   UP: dbit 1 ;PB5
0003            106   NXT: dbit 1 ;PB6
0004            107   RST: dbit 1 ;PB7
0005            108   mf: dbit 1
0006            109   seconds_flag: dbit 1
0007            110   s_flag: dbit 1 ; set to 1 every time a second has passed
0008            111   oven_flag: dbit 1
0009            112   
0009            113   ;TODO: check if one is enough
0030            114   DSEG at 30H
0030            115   x: ds 4
0034            116   y: ds 4
0038            117   BCD: ds 5
003D            118   selecting_state: ds 1
003E            119   oven_state: ds 1
003F            120   soak_time: ds 1
0040            121   soak_temp: ds 1
0041            122   reflow_time: ds 1
0042            123   reflow_temp: ds 2
0044            124   Count1ms:     ds 2 
0046            125   sec: ds 1
0047            126   temp: ds 1
0048            127   pwm_counter:  ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0049            128   pwm:          ds 1 ; pwm percentage
004A            129   seconds:      ds 1 ; a seconds counter attached to Timer 2 ISR
004B            130   
                574   $LIST
                135   ;commen$LIST
0B83            137   
0B83            138   CSEG
0B83            139   Init_All:
0B83            140            ; Configure all the pins for biderectional I/O
0B83 75AC00     141            mov     P3M1, #0x00
0B86 75AD00     142            mov     P3M2, #0x00
0B89 75B300     143            mov     P1M1, #0x00
0B8C 75B400     144            mov     P1M2, #0x00
0B8F 75B100     145            mov     P0M1, #0x00
0B92 75B200     146            mov     P0M2, #0x00
0B95            147            
0B95            148            ; Could be useful if reset errors !HELP
0B95 79C8       149            mov R1, #200
0B97 7868       150       mov R0, #104
0B99 D8FE       151       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
0B9B D9FA       152       djnz R1, $-4 ; 25us*200=5.0ms
0B9D            153   
0B9D 438E10     154            orl     CKCON, #0x10 ; CLK is the input for timer 1
0BA0 438780     155            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0BA3 759852     156            mov     SCON, #0x52
0BA6 53C4DF     157            anl     T3CON, #0b11011111
0BA9 53890F     158            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0BAC 438920     159            orl     TMOD, #0x20 ; Timer 1 Mode 2
0BAF 758DF7     160            mov     TH1, #TIMER1_RELOAD
0BB2 D28E       161            setb TR1
0BB4            162   
0BB4            163            ; Using timer 0 for delay functions.  Initialize here:
0BB4 C28C       164            clr     TR0 ; Stop timer 0
0BB6 438E08     165            orl     CKCON,#0x08 ; CLK is the input for timer 0
0BB9 5389F0     166            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0BBC 438901     167            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0BBF            168            
0BBF            169            ; Initialize and start the ADC:
0BBF            170            
0BBF            171            ; AIN0 is connected to P1.7.  Configure P1.7 as input.
0BBF 43B380     172            orl     P1M1, #0b10000000
0BC2 53B47F     173            anl     P1M2, #0b01111111
0BC5            174   
0BC5 754900     175            mov pwm, #0
0BC8 754800     176       mov pwm_counter, #0
0BCB            177            
0BCB            178            ; AINDIDS select if some pins are analog inputs or digital I/O:
0BCB 75F600     179            mov AINDIDS, #0x00 ; Disable all analog inputs
0BCE 43F601     180            orl AINDIDS, #0b00000001 ; Using AIN0
0BD1 43E101     181            orl ADCCON1, #0x01 ; Enable ADC
0BD4            182   
0BD4            183            ; timer 2 ?? 
0BD4 120C0C     184            lcall Timer2_Init
0BD7 D2AF       185            setb EA
0BD9            186   
0BD9            187            
0BD9 22         188            ret
0BDA            189            
0BDA            190   wait_1ms:
0BDA C28C       191            clr     TR0 ; Stop timer 0
0BDC C28D       192            clr     TF0 ; Clear overflow flag
0BDE 758CBF     193            mov     TH0, #high(TIMER0_RELOAD_1MS)
0BE1 758A28     194            mov     TL0,#low(TIMER0_RELOAD_1MS)
0BE4 D28C       195            setb TR0
0BE6 308DFD     196            jnb     TF0, $ ; Wait for overflow
0BE9 22         197            ret
0BEA            198   
0BEA            199   ; Wait the number of miliseconds in R2
0BEA            200   waitms:
0BEA 120BDA     201            lcall wait_1ms
0BED DAFB       202            djnz R2, waitms
0BEF 22         203            ret
0BF0            204   
0BF0            205   ;set cursor before, also might have to change format     
0BF0            206   Display_formated_BCD:  
0BF0            207       ;Display_BCD(bcd+4) 
0BF0            208       ;Display_BCD(bcd+3) 
0BF0 C000       209            push ar0
0BF2 A83A       209            mov r0, bcd+2
0BF4 120245     209            lcall ?Display_BCD
0BF7 D000       209            pop ar0 
0BF9 C000       210            push ar0
0BFB A839       210            mov r0, bcd+1
0BFD 120245     210            lcall ?Display_BCD
0C00 D000       210            pop ar0 
0C02 C000       211            push ar0
0C04 A838       211            mov r0, bcd+0
0C06 120245     211            lcall ?Display_BCD
0C09 D000       211            pop ar0  
0C0B 22         212       ret
0C0C            213   
0C0C            214   Timer2_Init:
0C0C 75C800     215            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0C0F 75CDD7     216            mov TH2, #high(TIMER2_RELOAD)
0C12 75CC79     217            mov TL2, #low(TIMER2_RELOAD)
0C15            218            ; Set the reload value
0C15 75C9A0     219            mov T2MOD, #1010_0000b ; !WIP could be causing timing issue?
0C18            220            ;orl T2MOD, #0x80 ; Enable timer 2 autoreload this was it before
0C18 75CBD7     221            mov RCMP2H, #high(TIMER2_RELOAD)
0C1B 75CA79     222            mov RCMP2L, #low(TIMER2_RELOAD)
0C1E            223            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0C1E E4         224            clr a
0C1F F544       225            mov Count1ms+0, a
0C21 F545       226            mov Count1ms+1, a
0C23 754A00     227            mov seconds, #0
0C26 C206       228            clr seconds_flag
0C28            229            ; Enable the timer and interrupts
0C28 439B80     230            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0C2B D2CA       231       setb TR2  ; Enable timer 2
0C2D 22         232            ret
0C2E            233   ;---------------------------------;
0C2E            234   ; ISR for timer 2                 ;
0C2E            235   ;---------------------------------;
0C2E            236            
0C2E            237   Timer2_ISR:
0C2E C2CF       238            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0C30            239            
0C30            240            ; The two registers used in the ISR must be saved in the stack
0C30 C0E0       241            push acc
0C32 C0D0       242            push psw
0C34 C034       243            push y+0
0C36 C035       243            push y+1
0C38 C036       243            push y+2
0C3A C037       243            push y+3
0C3C C030       244            push x+0
0C3E C031       244            push x+1
0C40 C032       244            push x+2
0C42 C033       244            push x+3
0C44            245            
0C44 0548       246       inc pwm_counter
0C46 C3         247            clr c
0C47 E549       248            mov a, pwm
0C49 9548       249            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0C4B B3         250            cpl c
0C4C 9290       251            mov PWM_OUT, c
0C4E            252            
0C4E E548       253            mov a, pwm_counter
0C50 B46407     254            cjne a, #100, Timer2_ISR_done
0C53 754800     255            mov pwm_counter, #0
0C56 054A       256            inc seconds ; It is super easy to keep a seconds count here
0C58 D206       257            setb seconds_flag
0C5A            258      
0C5A            259       ;inc seconds ; It is super easy to keep a seconds count here
0C5A            260   
0C5A            261   
0C5A            262            ;increment second flag 
0C5A            263   
0C5A            264            ;mov a, seconds
0C5A            265            ;add a, #1
0C5A            266            ;da A
0C5A            267            ;mov seconds, A
0C5A            268   
0C5A            269   
0C5A            270   ;Inc_Done:
0C5A            271            ; Check if second has passed
0C5A            272   ;        mov a, Count1ms+0
0C5A            273   ;        cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0C5A            274   ;        mov a, Count1ms+1
0C5A            275   ;        cjne a, #high(1000), Time_increment_done
0C5A            276            
0C5A            277            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0C5A            278   ;        setb seconds_flag ; Let the main program know a second had passed
0C5A            279            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0C5A            280            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0C5A            281   ;        clr a
0C5A            282   ;        mov Count1ms+0, a
0C5A            283   ;        mov Count1ms+1, a
0C5A            284            ; Increment the time only when state flag is on
0C5A            285            ;jnb state, Time_increment_done
0C5A            286            
0C5A            287   ;        mov a, sec
0C5A            288   ;        add a, #0x01
0C5A            289   ;        da a
0C5A            290   ;        mov sec, a
0C5A            291   ;        
0C5A            292   ;        cjne a, #0x60, Time_increment_done
0C5A            293   
0C5A            294                    
0C5A            295   Timer2_ISR_done:
0C5A D033       296            pop x+3
0C5C D032       296            pop x+2
0C5E D031       296            pop x+1
0C60 D030       296            pop x+0
0C62 D037       297            pop y+3
0C64 D036       297            pop y+2
0C66 D035       297            pop y+1
0C68 D034       297            pop y+0
0C6A D0D0       298            pop psw
0C6C D0E0       299            pop acc
0C6E 32         300            reti
0C6F            301   
0C6F            302   
0C6F            303   
0C6F            304   
0C6F            305   
0C6F            306   
0C6F            307   
0C6F            308   ADC_to_PB:
0C6F C0E0       309            push acc
0C71 53E8F0     310            anl ADCCON0, #0xF0
0C74 43E800     311            orl ADCCON0, #0x00 ; Select AIN0
0C77            312            
0C77 C2EF       313            clr ADCF
0C79 D2EE       314            setb ADCS   ; ADC start trigger signal
0C7B 30EFFD     315       jnb ADCF, $ ; Wait for conversion complete
0C7E            316   
0C7E D204       317            setb RST;PB7
0C80 D203       318            setb NXT;PB6
0C82 D202       319            setb UP;PB5
0C84 D201       320            setb DOWN;PB4
0C86 D200       321            setb S_S;PB3
0C88            322            ;setb PB2
0C88            323            ;setb PB1
0C88            324            ;setb PB0
0C88            325            
0C88            326            ; Check PB7
0C88            327   ;ADC_to_PB_L7:
0C88            328   ;        clr c
0C88            329   ;        mov a, ADCRH
0C88            330   ;        subb a, #0xf0
0C88            331   ;        jc ADC_to_PB_L6
0C88            332   ;        clr RST;PB7
0C88            333   ;        ret
0C88            334   ;
0C88            335   ;        ; Check PB6
0C88            336   ;ADC_to_PB_L6:
0C88            337   ;        clr c
0C88            338   ;        mov a, ADCRH
0C88            339   ;        subb a, #0xd0
0C88            340   ;        jc ADC_to_PB_L5
0C88            341   ;        clr NXT;PB6
0C88            342   ;        ret
0C88            343   
0C88            344            ; Check PB5
0C88            345   ADC_to_PB_L5:
0C88 C3         346            clr c
0C89 E5C3       347            mov a, ADCRH
0C8B 94B0       348            subb a, #0xb0
0C8D 4005       349            jc ADC_to_PB_L4
0C8F C204       350            clr RST;PB5
0C91 D0E0       351            pop acc
0C93 22         352            ret
0C94            353   
0C94            354            ; Check PB4
0C94            355   ADC_to_PB_L4:
0C94 C3         356            clr c
0C95 E5C3       357            mov a, ADCRH
0C97 9490       358            subb a, #0x90
0C99 4005       359            jc ADC_to_PB_L3
0C9B C203       360            clr NXT;PB4
0C9D D0E0       361            pop acc
0C9F 22         362            ret
0CA0            363   
0CA0            364            ; Check PB3
0CA0            365   ADC_to_PB_L3:
0CA0 C3         366            clr c
0CA1 E5C3       367            mov a, ADCRH
0CA3 9470       368            subb a, #0x70
0CA5 4005       369            jc ADC_to_PB_L2
0CA7 C202       370            clr UP;PB3
0CA9 D0E0       371            pop acc
0CAB 22         372            ret
0CAC            373   
0CAC            374            ; Check PB2
0CAC            375   ADC_to_PB_L2:
0CAC C3         376            clr c
0CAD E5C3       377            mov a, ADCRH
0CAF 9450       378            subb a, #0x50
0CB1 4005       379            jc ADC_to_PB_L1
0CB3 C201       380            clr DOWN
0CB5 D0E0       381            pop acc
0CB7 22         382            ret
0CB8            383   
0CB8            384            ; Check PB1
0CB8            385   ADC_to_PB_L1:
0CB8 C3         386            clr c
0CB9 E5C3       387            mov a, ADCRH
0CBB 9430       388            subb a, #0x30
0CBD 4005       389            jc ADC_to_PB_L0
0CBF C200       390            clr S_S
0CC1 D0E0       391            pop acc
0CC3 22         392            ret
0CC4            393   
0CC4            394            ; Check PB0
0CC4            395   ADC_to_PB_L0:
0CC4 C3         396            clr c
0CC5 E5C3       397            mov a, ADCRH
0CC7 9410       398            subb a, #0x10
0CC9 4003       399            jc ADC_to_PB_Done
0CCB            400            ;clr PB0
0CCB D0E0       401            pop acc
0CCD 22         402            ret
0CCE            403            
0CCE            404   ADC_to_PB_Done:
0CCE            405            ; No pusbutton pressed  
0CCE D0E0       406            pop acc
0CD0 22         407            ret
0CD1            408            
0CD1            409   main:
0CD1 75817F     410            mov sp, #0x7f
0CD4 120616     411            lcall Temp_Init_All
0CD7 120B83     412            lcall Init_All
0CDA 120200     413       lcall LCD_4BIT
0CDD            414       
0CDD 12025B     415       lcall state_init ;From State_Machine.inc
0CE0            416       
0CE0            417       ; initial messages in LCD
0CE0 C0E0       418            push acc
0CE2 7401       418            mov a, #1
0CE4 14         418            dec a
0CE5 120240     418            lcall ?Set_Cursor_1 ; Select column and row
0CE8 D0E0       418            pop acc
0CEA C083       419            push dph
0CEC C082       419            push dpl
0CEE C0E0       419            push acc
0CF0 90002E     419            mov dptr, #Title
0CF3 120233     419            lcall ?Send_Constant_String
0CF6 D0E0       419            pop acc
0CF8 D082       419            pop dpl
0CFA D083       419            pop dph
0CFC C0E0       420            push acc
0CFE 7401       420            mov a, #1
0D00 14         420            dec a
0D01 12023E     420            lcall ?Set_Cursor_2 ; Select column and row
0D04 D0E0       420            pop acc
0D06 C083       421            push dph
0D08 C082       421            push dpl
0D0A C0E0       421            push acc
0D0C 90003E     421            mov dptr, #blank
0D0F 120233     421            lcall ?Send_Constant_String
0D12 D0E0       421            pop acc
0D14 D082       421            pop dpl
0D16 D083       421            pop dph
0D18            422   
0D18 7AFA       423            mov R2, #250
0D1A 120BEA     424            lcall waitms
0D1D            425            
0D1D            426   Forever:
0D1D            427            ; Wait 50 ms between readings
0D1D 7A32       428            mov R2, #50
0D1F 120BEA     429            lcall waitms
0D22            430   
0D22            431            ; output? 
0D22 300604     432            jnb seconds_flag, no_second
0D25 C206       433            clr seconds_flag
0D27 B295       434            cpl P1.5
0D29            435   
0D29            436   no_second:
0D29            437   
0D29 7A32       438            mov R2, #50
0D2B 120BEA     439            lcall waitms
0D2E            440   
0D2E 020D31     441            ljmp FSM_select
0D31            442   
0D31            443            ;Set_Cursor(2, 11)
0D31            444            ;mov r0, #80
0D31            445            ;mov x+0, r0
0D31            446            ;mov x+1, #0 
0D31            447            ;mov x+2, #0
0D31            448            ;mov x+3, #0
0D31            449            ;lcall hex2bcd
0D31            450            ;lcall Display_formated_BCD
0D31            451            
0D31            452            ;check if reaches forever
0D31            453            ;Set_Cursor(1, 1)
0D31            454            ;Send_Constant_String(#forever_message)
0D31            455            ;mov R2, #250
0D31            456            ;lcall waitms
0D31            457            ;ljmp FSM_select
0D31            458   
0D31            459   ;no_second:
0D31            460   ;        ljmp Forever
0D31            461   
0D31            462   ;for testing since there's no other fsm right now
0D31            463   
0D31            464   
0D31            465   ;begin select FSM
0D31            466   FSM_select:
0D31 E53D       467            mov a, selecting_state
0D33            468   
0D33            469   select_wait:
0D33 B4004C     470            cjne a, #0, select_soak_time ;checks the state
0D36 C0E0       471            push acc
0D38 7401       471            mov a, #1
0D3A 14         471            dec a
0D3B 120240     471            lcall ?Set_Cursor_1 ; Select column and row
0D3E D0E0       471            pop acc
0D40 C083       472            push dph
0D42 C082       472            push dpl
0D44 C0E0       472            push acc
0D46 90004F     472            mov dptr, #swait_message1
0D49 120233     472            lcall ?Send_Constant_String
0D4C D0E0       472            pop acc
0D4E D082       472            pop dpl
0D50 D083       472            pop dph
0D52 C0E0       473            push acc
0D54 7401       473            mov a, #1
0D56 14         473            dec a
0D57 12023E     473            lcall ?Set_Cursor_2 ; Select column and row
0D5A D0E0       473            pop acc
0D5C C083       474            push dph
0D5E C082       474            push dpl
0D60 C0E0       474            push acc
0D62 900060     474            mov dptr, #swait_message2
0D65 120233     474            lcall ?Send_Constant_String
0D68 D0E0       474            pop acc
0D6A D082       474            pop dpl
0D6C D083       474            pop dph
0D6E 7AFA       475            mov R2, #250
0D70 120BEA     476            lcall waitms
0D73            477       ;lcall ADC_to_PB ;checks for button press
0D73 120F91     478       lcall rst_check
0D76 120F9C     479       lcall nxt_check
0D79 12105F     480       lcall s_s_check
0D7C 020D1D     481       ljmp forever ;i believe 
0D7F            482   
0D7F            483   select_soak_temp_ah:
0D7F 020E07     484            ljmp select_soak_temp
0D82            485   
0D82            486   select_soak_time:
0D82 B401FA     487            cjne a, #1, select_soak_temp_ah ;checks the state
0D85 C0E0       488            push acc
0D87 7401       488            mov a, #1
0D89 14         488            dec a
0D8A 120240     488            lcall ?Set_Cursor_1 ; Select column and row
0D8D D0E0       488            pop acc
0D8F C083       489            push dph
0D91 C082       489            push dpl
0D93 C0E0       489            push acc
0D95 900071     489            mov dptr, #sstime_message1
0D98 120233     489            lcall ?Send_Constant_String
0D9B D0E0       489            pop acc
0D9D D082       489            pop dpl
0D9F D083       489            pop dph
0DA1 C0E0       490            push acc
0DA3 7401       490            mov a, #1
0DA5 14         490            dec a
0DA6 12023E     490            lcall ?Set_Cursor_2 ; Select column and row
0DA9 D0E0       490            pop acc
0DAB C083       491            push dph
0DAD C082       491            push dpl
0DAF C0E0       491            push acc
0DB1 900082     491            mov dptr, #sstime_message2
0DB4 120233     491            lcall ?Send_Constant_String
0DB7 D0E0       491            pop acc
0DB9 D082       491            pop dpl
0DBB D083       491            pop dph
0DBD            492       ;Set_Cursor(2, 11)
0DBD C005       493       push AR5  ;display the current soak_time
0DBF AD30       494       mov R5, x
0DC1 853F30     495       mov x+0, soak_time
0DC4 753100     496            mov x+1, #0
0DC7 753200     497            mov x+2, #0
0DCA 753300     498            mov x+3, #0
0DCD C0E0       499            push acc
0DCF 740B       499            mov a, #11
0DD1 14         499            dec a
0DD2 12023E     499            lcall ?Set_Cursor_2 ; Select column and row
0DD5 D0E0       499            pop acc
0DD7            500            ;Send_Constant_String(#its_works)
0DD7 1203A6     501       lcall hex2bcd
0DDA 120BF0     502       lcall Display_formated_BCD
0DDD 8D30       503       mov x, R5
0DDF D005       504       pop AR5
0DE1            505       ;lcall ADC_to_PB ;checks for button press
0DE1 120F91     506       lcall rst_check
0DE4 C003       507       push AR3 ;set the paramaters for up/down
0DE6 C004       508       push AR4
0DE8 C005       509       push AR5
0DEA 7B3C       510       mov R3, #0x3C ;min value allowed for soak time !check it please
0DEC 7C78       511       mov R4, #0x78 ;120  ;max value, !check it please, also is the dec? hex?
0DEE AD3F       512       mov R5, soak_time
0DF0 120FCF     513       lcall up_check
0DF3 121017     514       lcall down_check
0DF6 8D3F       515       mov soak_time, R5
0DF8 D005       516       pop AR5
0DFA D004       517       pop AR4
0DFC D003       518       pop AR3  ;am i doing this right?
0DFE 12105F     519       lcall s_s_check
0E01 120F9C     520       lcall nxt_check
0E04 020D1D     521       ljmp forever ;i believe 
0E07            522   
0E07            523   select_soak_temp:
0E07 B40203     524            cjne a, #2, $+6 ;checks the state
0E0A 020E10     525            ljmp $+6
0E0D 020E9C     526            ljmp select_reflow_time
0E10 C0E0       527            push acc
0E12 7401       527            mov a, #1
0E14 14         527            dec a
0E15 120240     527            lcall ?Set_Cursor_1 ; Select column and row
0E18 D0E0       527            pop acc
0E1A C083       528            push dph
0E1C C082       528            push dpl
0E1E C0E0       528            push acc
0E20 900093     528            mov dptr, #sstemp_message1
0E23 120233     528            lcall ?Send_Constant_String
0E26 D0E0       528            pop acc
0E28 D082       528            pop dpl
0E2A D083       528            pop dph
0E2C C0E0       529            push acc
0E2E 7401       529            mov a, #1
0E30 14         529            dec a
0E31 12023E     529            lcall ?Set_Cursor_2 ; Select column and row
0E34 D0E0       529            pop acc
0E36 C083       530            push dph
0E38 C082       530            push dpl
0E3A C0E0       530            push acc
0E3C 9000A4     530            mov dptr, #sstemp_message2
0E3F 120233     530            lcall ?Send_Constant_String
0E42 D0E0       530            pop acc
0E44 D082       530            pop dpl
0E46 D083       530            pop dph
0E48 C0E0       531            push acc
0E4A 740B       531            mov a, #11
0E4C 14         531            dec a
0E4D 12023E     531            lcall ?Set_Cursor_2 ; Select column and row
0E50 D0E0       531            pop acc
0E52 C005       532       push AR5  ;display current soak temp
0E54 C030       533            push x+0
0E56 C031       533            push x+1
0E58 C032       533            push x+2
0E5A C033       533            push x+3
0E5C 854030     534            mov x+0, soak_temp
0E5F 753100     535            mov x+1, #0
0E62 753200     536            mov x+2, #0
0E65 753300     537            mov x+3, #0
0E68 1203A6     538       lcall hex2bcd
0E6B 120BF0     539       lcall Display_formated_BCD
0E6E            540       ;mov x, R5
0E6E D033       541            pop x+3
0E70 D032       541            pop x+2
0E72 D031       541            pop x+1
0E74 D030       541            pop x+0
0E76            542       ;lcall ADC_to_PB ;checks for button press
0E76 120F91     543       lcall rst_check
0E79 C003       544       push AR3 ;set the paramaters for up/down
0E7B C004       545       push AR4
0E7D C005       546       push AR5
0E7F 7B96       547       mov R3, #0x96 ;min value allowed !check it please (150 decimal)
0E81 7CC8       548       mov R4, #0xC8 ;max value, !check it please, also is the dec? hex? (200 decimal)
0E83 AD40       549       mov R5, soak_temp
0E85 120FCF     550       lcall up_check
0E88 121017     551       lcall down_check
0E8B 8D40       552       mov soak_temp, R5
0E8D D005       553       pop AR5
0E8F D004       554       pop AR4
0E91 D003       555       pop AR3  ;am i doing this right?
0E93 12105F     556       lcall s_s_check
0E96 120F9C     557       lcall nxt_check
0E99 020D1D     558       ljmp forever ;i believe 
0E9C            559   
0E9C            560   select_reflow_time:
0E9C B40379     561            cjne a, #3, select_reflow_temp ;checks the state
0E9F C0E0       562            push acc
0EA1 7401       562            mov a, #1
0EA3 14         562            dec a
0EA4 120240     562            lcall ?Set_Cursor_1 ; Select column and row
0EA7 D0E0       562            pop acc
0EA9 C083       563            push dph
0EAB C082       563            push dpl
0EAD C0E0       563            push acc
0EAF 9000B5     563            mov dptr, #srtime_message1
0EB2 120233     563            lcall ?Send_Constant_String
0EB5 D0E0       563            pop acc
0EB7 D082       563            pop dpl
0EB9 D083       563            pop dph
0EBB C0E0       564            push acc
0EBD 7401       564            mov a, #1
0EBF 14         564            dec a
0EC0 12023E     564            lcall ?Set_Cursor_2 ; Select column and row
0EC3 D0E0       564            pop acc
0EC5 C083       565            push dph
0EC7 C082       565            push dpl
0EC9 C0E0       565            push acc
0ECB 9000C6     565            mov dptr, #srtime_message2
0ECE 120233     565            lcall ?Send_Constant_String
0ED1 D0E0       565            pop acc
0ED3 D082       565            pop dpl
0ED5 D083       565            pop dph
0ED7 C0E0       566            push acc
0ED9 740B       566            mov a, #11
0EDB 14         566            dec a
0EDC 12023E     566            lcall ?Set_Cursor_2 ; Select column and row
0EDF D0E0       566            pop acc
0EE1 C005       567       push AR5  ;display current reflow time
0EE3 AD30       568       mov R5, x
0EE5 854130     569       mov x, reflow_time
0EE8 1203A6     570       lcall hex2bcd
0EEB 120BF0     571       lcall Display_formated_BCD
0EEE 8D30       572       mov x, R5
0EF0 D005       573       pop AR5
0EF2            574       ;lcall ADC_to_PB ;checks for button press
0EF2 120F91     575       lcall rst_check
0EF5 C003       576       push AR3 ;set the paramaters for up/down
0EF7 C004       577       push AR4
0EF9 C005       578       push AR5
0EFB 7B00       579       mov R3, #0x00 ;45 min value allowed !check it please
0EFD 7C2D       580       mov R4, #0x2D ;75 max value, !check it please, also is the dec? hex?
0EFF AD41       581       mov R5, reflow_time
0F01 120FCF     582       lcall up_check
0F04 121017     583       lcall down_check
0F07 8D41       584       mov reflow_time, R5
0F09 D005       585       pop AR5
0F0B D004       586       pop AR4
0F0D D003       587       pop AR3  ;am i doing this right?
0F0F 12105F     588       lcall s_s_check
0F12 120F9C     589       lcall nxt_check
0F15 020D1D     590       ljmp forever ;i believe 
0F18            591   
0F18            592   select_reflow_temp:
0F18            593            ;shouldn't need to check the state
0F18 C0E0       594            push acc
0F1A 7401       594            mov a, #1
0F1C 14         594            dec a
0F1D 120240     594            lcall ?Set_Cursor_1 ; Select column and row
0F20 D0E0       594            pop acc
0F22 C083       595            push dph
0F24 C082       595            push dpl
0F26 C0E0       595            push acc
0F28 9000D7     595            mov dptr, #srtemp_message1
0F2B 120233     595            lcall ?Send_Constant_String
0F2E D0E0       595            pop acc
0F30 D082       595            pop dpl
0F32 D083       595            pop dph
0F34 C0E0       596            push acc
0F36 7401       596            mov a, #1
0F38 14         596            dec a
0F39 12023E     596            lcall ?Set_Cursor_2 ; Select column and row
0F3C D0E0       596            pop acc
0F3E C083       597            push dph
0F40 C082       597            push dpl
0F42 C0E0       597            push acc
0F44 9000E8     597            mov dptr, #srtemp_message2
0F47 120233     597            lcall ?Send_Constant_String
0F4A D0E0       597            pop acc
0F4C D082       597            pop dpl
0F4E D083       597            pop dph
0F50 C0E0       598            push acc
0F52 740B       598            mov a, #11
0F54 14         598            dec a
0F55 12023E     598            lcall ?Set_Cursor_2 ; Select column and row
0F58 D0E0       598            pop acc
0F5A C005       599       push AR5  ;display current reflow temp
0F5C AD30       600       mov R5, x
0F5E 854230     601       mov x, reflow_temp
0F61 1203A6     602       lcall hex2bcd
0F64 120BF0     603       lcall Display_formated_BCD
0F67 8D30       604       mov x, R5
0F69 D005       605       pop AR5
0F6B            606       ;lcall ADC_to_PB ;checks for button press
0F6B 120F91     607       lcall rst_check
0F6E C003       608       push AR3  ;set the paramaters for up/down
0F70 C004       609       push AR4
0F72 C005       610       push AR5
0F74 7BD9       611       mov R3, #0xD9 ;217 DEC ;min value allowed !check it please
0F76 7CF0       612       mov R4, #0xF0 ; 255 DEC ;max value, !check it please, also is the dec? hex?
0F78 AD42       613       mov R5, reflow_temp
0F7A 120FCF     614       lcall up_check
0F7D 121017     615       lcall down_check
0F80 8D42       616       mov reflow_temp, R5
0F82 D005       617       pop AR5
0F84 D004       618       pop AR4
0F86 D003       619       pop AR3  ;am i doing this right?
0F88 12105F     620       lcall s_s_check
0F8B 120F9C     621       lcall nxt_check
0F8E 020D1D     622       ljmp forever ;i believe 
0F91            623   
0F91            624   ;maybe make these macros :(
0F91            625   ;use R3 & R4 & R5 as parameters
0F91            626   rst_check:
0F91 120C6F     627            lcall ADC_to_PB
0F94 A204       628            mov c, RST
0F96 5001       629       jnc rst_check_0 ;!could be jc
0F98 22         630       ret
0F99            631   rst_check_0:
0F99 02026B     632       ljmp reset_state ;or whatever it's called, wait state of oven fsm
0F9C            633   
0F9C            634   nxt_check:
0F9C 120C6F     635            lcall ADC_to_PB
0F9F A203       636            mov c, NXT
0FA1 5001       637       jnc next_check_1 
0FA3 22         638            ret
0FA4            639   next_check_1: 
0FA4            640       ;load_x(selecting_state)
0FA4            641       ;load_y(4)
0FA4 853D30     642            mov x, selecting_state
0FA7 753100     643            mov x+1, #0
0FAA 753200     644            mov x+2, #0
0FAD 753300     645            mov x+3, #0
0FB0 753404     646            mov y, #0x04
0FB3 753500     647            mov y+1, #0
0FB6 753600     648            mov y+2, #0
0FB9 753700     649            mov y+3, #0
0FBC 1204E6     650       lcall x_eq_y
0FBF D3         651            setb c
0FC0 200507     652            jb mf, next_check_2
0FC3 E53D       653       mov a, selecting_state 
0FC5 3400       654       addc a, #0 ;uh
0FC7 F53D       655       mov selecting_state, a
0FC9 22         656       ret
0FCA            657   next_check_2:
0FCA C3         658            clr c
0FCB 753D00     659            mov selecting_state, #0 ;can't go above 4 (there are 5 states)
0FCE            660   
0FCE 22         661            ret
0FCF            662   
0FCF            663   up_check: ;R4 max
0FCF 120C6F     664            lcall ADC_to_PB
0FD2 A202       665            mov c, UP
0FD4 5001       666            jnc up_check_1
0FD6 22         667            ret 
0FD7            668   up_check_1:
0FD7 8C30       669            mov x, R4
0FD9 753100     670            mov x+1, #0
0FDC 753200     671            mov x+2, #0
0FDF 753300     672            mov x+3, #0
0FE2 8D34       673            mov y, R5
0FE4 753500     674            mov y+1, #0
0FE7 753600     675            mov y+2, #0
0FEA 753700     676            mov y+3, #0
0FED 1204CA     677            lcall x_gt_y ;max > value
0FF0 D3         678            setb c
0FF1 300505     679            jnb mf, up_check_2
0FF4 ED         680            mov a, R5
0FF5 3400       681            addc a, #0 ;dec? hex?
0FF7 FD         682            mov R5, a
0FF8 22         683            ret
0FF9            684   up_check_2:
0FF9 C3         685            clr c
0FFA C0E0       686            push acc
0FFC 740B       686            mov a, #11
0FFE 14         686            dec a
0FFF 12023E     686            lcall ?Set_Cursor_2 ; Select column and row
1002 D0E0       686            pop acc
1004 C083       687            push dph
1006 C082       687            push dpl
1008 C0E0       687            push acc
100A 9000F9     687            mov dptr, #too_high_message
100D 120233     687            lcall ?Send_Constant_String
1010 D0E0       687            pop acc
1012 D082       687            pop dpl
1014 D083       687            pop dph
1016 22         688            ret
1017            689   
1017            690   down_check: ;R3 min
1017 120C6F     691            lcall ADC_to_PB
101A A201       692            mov c, DOWN
101C 5001       693            jnc down_check_1
101E 22         694            ret
101F            695   down_check_1:
101F 8B30       696            mov x, R3
1021 753100     697            mov x+1, #0
1024 753200     698            mov x+2, #0
1027 753300     699            mov x+3, #0
102A 8D34       700            mov y, R5
102C 753500     701            mov y+1, #0
102F 753600     702            mov y+2, #0
1032 753700     703            mov y+3, #0
1035 1204AE     704            lcall x_lt_y ;min < value
1038 D3         705            setb c
1039 300505     706            jnb mf, down_check_2
103C ED         707            mov a, R5
103D 9400       708            subb a, #0 ;dec? hex?
103F FD         709            mov R5, a
1040 22         710            ret
1041            711   down_check_2:
1041 C3         712            clr c
1042 C0E0       713            push acc
1044 740B       713            mov a, #11
1046 14         713            dec a
1047 12023E     713            lcall ?Set_Cursor_2 ; Select column and row
104A D0E0       713            pop acc
104C C083       714            push dph
104E C082       714            push dpl
1050 C0E0       714            push acc
1052 900103     714            mov dptr, #too_low_message
1055 120233     714            lcall ?Send_Constant_String
1058 D0E0       714            pop acc
105A D082       714            pop dpl
105C D083       714            pop dph
105E 22         715            ret
105F            716   
105F            717   s_s_check:
105F 120C6F     718            lcall ADC_to_PB
1062 A200       719            mov c, S_S
1064 5001       720            jnc s_s_check_done ;!could be jb
1066 22         721            ret
1067            722   s_s_check_done:
1067 020730     723            ljmp FSM_Init ;or whatever it's called, 1st state of oven FSM
106A            724   
106A            725   END
