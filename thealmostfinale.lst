0000              1   ;please work
0000              2   ; do not touch functional except for
0000              3   ; pwm and load_X i think 
0000              4   
0000              5   
0000              6   ;with 5 adc push buttons
0000              7   ;to think about:
0000              8            ;adding another state for when start is pressed so that in forever if it gets sent back to FSM_select
0000              9            ;it will know not to ask for input/go through it
0000             10            ;making the checks into macros
0000             11   
0000             12   ;button functions: rst, next, up, down, start/stop
0000             13   ;display which you're in 
0000             14   ;start-> in the selecting fsm
0000             15   ;stop-> after reset_state in the oven fsm
0000             16   
0000             17   ; 76E003 ADC_Pushbuttons.asm: Reads push buttons using the ADC, AIN0 in P1.7
0000             18   
                 20   $LIST
0000             22   
0000             23   ;  N76E003 pinout:
0000             24   ;                               -------
0000             25   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             26   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             27   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             28   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             29   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             30   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             31   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             32   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             33   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             34   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             35   ;                               -------
0000             36   ;
0000             37   
0000             38   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             39   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             40   TIMER1_RATE         EQU 1000      ; 100Hz or 10ms
0000             41   TIMER1_RELOAD       EQU (65536-(CLK/(TIMER1_RATE))) ; Need to change timer 1 input divide to 16 in T2MOD
0000             42   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             43   TIMER2_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             44   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE)))
0000             45   
0000             46   ORG 0x0000
0000 020BDF      47            ljmp main
0003             48            
0003             49   
001B             50   ORG 0x001B
001B 32          51            reti
001C             52   
002B             53   ORG 0x002B
002B 020B40      54            ljmp Timer2_ISR
002E             55   
002E             56   
002E             57   ;                     1234567890123456    <- This helps determine the location of the counter
002E 20206865    58   title:            db '  here we go!  ', 0
     72652077
     6520676F
     21202000
003E 20202020    59   blank:            db '                ', 0
     20202020
     20202020
     20202020
     00
004F 53657420    60   swait_message1:   db 'Set your values ', 0   ;s->select fsm, wait->state
     796F7572
     2076616C
     75657320
     00
0060 50726573    61   swait_message2:   db 'Press next      ', 0
     73206E65
     78742020
     20202020
     00
0071 53656C65    62   sstime_message1:  db 'Select soak time', 0   ;s->soak
     63742073
     6F616B20
     74696D65
     00
0082 536F616B    63   sstime_message2:  db 'Soak time:      ', 0
     2074696D
     653A2020
     20202020
     00
0093 53656C65    64   sstemp_message1:  db 'Select soak temp', 0   ;s->soak
     63742073
     6F616B20
     74656D70
     00
00A4 536F616B    65   sstemp_message2:  db 'Soak temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00B5 53656C65    66   srtime_message1:  db 'Select refl time', 0   ;r->reflow
     63742072
     65666C20
     74696D65
     00
00C6 5265666C    67   srtime_message2:  db 'Refl time:      ', 0
     2074696D
     653A2020
     20202020
     00
00D7 53656C65    68   srtemp_message1:  db 'Select refl temp', 0   ;r->reflow
     63742072
     65666C20
     74656D70
     00
00E8 5265666C    69   srtemp_message2:  db 'Refl temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00F9 6D617821    70   too_high_message: db 'max!     ', 0
     20202020
     2000
0103 6D696E21    71   too_low_message:  db 'min!     ', 0
     20202020
     2000
010D 68656C6C    72   forever_message:  db 'hello please', 0
     6F20706C
     65617365
     00
011A 64696500    73   its_works:        db 'die',0
011E 646F6E65    74   done_message:      db 'done!',0
     2100
0124 73746F70    75   stop_message:      db 'stopped!',0
     70656421
     00
012D             76                                               ;1234567890123456
012D 4F76656E    77   oven_fsm_message_0: db 'Oven State 0!   ',0
     20537461
     74652030
     21202020
     00
013E 4F76656E    78   oven_fsm_message_1: db 'Oven State 1!   ',0
     20537461
     74652031
     21202020
     00
014F 4F76656E    79   oven_fsm_message_2: db 'Oven State 2!   ',0
     20537461
     74652032
     21202020
     00
0160 4F76656E    80   oven_fsm_message_3: db 'Oven State 3!   ',0
     20537461
     74652033
     21202020
     00
0171 4F76656E    81   oven_fsm_message_4: db 'Oven State 4!   ',0
     20537461
     74652034
     21202020
     00
0182 4F76656E    82   oven_fsm_message_5: db 'Oven State 5!   ',0
     20537461
     74652035
     21202020
     00
0193             83   ;                                                   1234567890123456
0193 53657474    84   reset_state_message:   db 'Settings Reset! ', 0 ;for testing
     696E6773
     20526573
     65742120
     00
01A4 73746174    85   state1_message:   db 'state1          ', 0 ;for testing
     65312020
     20202020
     20202020
     00
01B5             86   
01B5             87   cseg
01B5             88   ; These 'equ' must match the hardware wiring
01B5             89   LCD_RS equ P1.3
01B5             90   LCD_E  equ P1.4
01B5             91   LCD_D4 equ P0.0
01B5             92   LCD_D5 equ P0.1
01B5             93   LCD_D6 equ P0.2
01B5             94   LCD_D7 equ P0.3
01B5             95   SOUND_OUT equ P1.5
01B5             96   PWM_OUT   EQU P1.0 ; Logic 1=oven on
01B5             97   
                100   ;                     1234567890123456    <- This helps determine the location of the counte$LIST
02BC            102   
0000            103   BSEG
0000            104   ; These eight bit variables store the value of the pushbuttons after calling 'ADC_to_PB' below
0000            105   ;PB0: dbit 1 
0000            106   ;PB1: dbit 1     pretty sure left-right is 7-0
0000            107   ;PB2: dbit 1
0000            108   S_S: dbit 1 ;PB3
0001            109   DOWN: dbit 1 ;PB4
0002            110   UP: dbit 1 ;PB5
0003            111   NXT: dbit 1 ;PB6
0004            112   RST: dbit 1 ;PB7
0005            113   mf: dbit 1
0006            114   seconds_flag: dbit 1
0007            115   s_flag: dbit 1 ; set to 1 every time a second has passed
0008            116   oven_flag: dbit 1
0009            117   
0009            118   ;TODO: check if one is enough
0030            119   DSEG at 30H
0030            120   x: ds 4
0034            121   y: ds 4
0038            122   BCD: ds 5
003D            123   selecting_state: ds 1
003E            124   oven_state: ds 1
003F            125   soak_time: ds 1
0040            126   soak_temp: ds 1
0041            127   reflow_time: ds 1
0042            128   reflow_temp: ds 2
0044            129   Count1ms:     ds 2 
0046            130   sec: ds 1
0047            131   temp: ds 1
0048            132   pwm_counter:  ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0049            133   pwm:          ds 1 ; pwm percentage
004A            134   seconds:      ds 1 ; a seconds counter attached to Timer 2 ISR
004B            135   
                574   $LIST
                139       $LIST
0A7F            141   
0A7F            142   CSEG
0A7F            143   Init_All:
0A7F            144            ; Configure all the pins for biderectional I/O
0A7F 75AC00     145            mov     P3M1, #0x00
0A82 75AD00     146            mov     P3M2, #0x00
0A85 75B300     147            mov     P1M1, #0x00
0A88 75B400     148            mov     P1M2, #0x00
0A8B 75B100     149            mov     P0M1, #0x00
0A8E 75B200     150            mov     P0M2, #0x00
0A91            151            
0A91            152   ;        orl     CKCON, #0x10 ; CLK is the input for timer 1
0A91            153   ;        orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0A91            154   ;        mov     SCON, #0x52
0A91            155   ;        anl     T3CON, #0b11011111
0A91            156   ;        anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0A91            157   ;        orl     TMOD, #0x20 ; Timer 1 Mode 2
0A91            158       ; Timer 1 for 1ms ticks
0A91 C28E       159       clr TR1  ; Stop timer 1
0A93 758910     160       mov TMOD, #0x10 ; Timer 1 Mode 1 (16-bit)
0A96 758DBF     161       mov TH1, #high(TIMER1_RELOAD)
0A99 758B28     162       mov TL1, #low(TIMER1_RELOAD)
0A9C D2AB       163       setb ET1  ; Enable Timer 1 interrupt
0A9E D28E       164       setb TR1  ; Start Timer 1
0AA0            165            
0AA0            166            ; Using timer 0 for delay functions.  Initialize here:
0AA0 C28C       167            clr     TR0 ; Stop timer 0
0AA2 438E08     168            orl     CKCON,#0x08 ; CLK is the input for timer 0
0AA5 5389F0     169            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0AA8 438901     170            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0AAB            171            
0AAB            172            ; Initialize and start the ADC:
0AAB            173            
0AAB            174            ; AIN0 is connected to P1.7.  Configure P1.7 as input.
0AAB 43B380     175            orl     P1M1, #0b10000000
0AAE 53B47F     176            anl     P1M2, #0b01111111
0AB1            177   
0AB1 754800     178       mov pwm_counter, #0
0AB4 754900     179            mov pwm, #0
0AB7            180   
0AB7            181            ; AINDIDS select if some pins are analog inputs or digital I/O:
0AB7 75F600     182            mov AINDIDS, #0x00 ; Disable all analog inputs
0ABA 43F601     183            orl AINDIDS, #0b00000001 ; Using AIN0
0ABD 43E101     184            orl ADCCON1, #0x01 ; Enable ADC
0AC0            185   
0AC0            186            ; timer 2 ?? 
0AC0 120B2B     187            lcall Timer2_Init
0AC3 D2AF       188            setb EA
0AC5            189   
0AC5            190            
0AC5 22         191            ret
0AC6            192            
0AC6            193   wait_1ms:
0AC6 C28C       194            clr     TR0 ; Stop timer 0
0AC8 C28D       195            clr     TF0 ; Clear overflow flag
0ACA 758CBF     196            mov     TH0, #high(TIMER0_RELOAD_1MS)
0ACD 758A28     197            mov     TL0,#low(TIMER0_RELOAD_1MS)
0AD0 D28C       198            setb TR0
0AD2 308DFD     199            jnb     TF0, $ ; Wait for overflow
0AD5 22         200            ret
0AD6            201   
0AD6            202   ; Wait the number of miliseconds in R2
0AD6            203   waitms:
0AD6 120AC6     204            lcall wait_1ms
0AD9 DAFB       205            djnz R2, waitms
0ADB 22         206            ret
0ADC            207   
0ADC            208   ;set cursor before, also might have to change format     
0ADC            209   Display_formated_BCD:  
0ADC            210       ;Display_BCD(bcd+4) 
0ADC            211       ;Display_BCD(bcd+3) 
0ADC C000       212            push ar0
0ADE A83A       212            mov r0, bcd+2
0AE0 120253     212            lcall ?Display_BCD
0AE3 D000       212            pop ar0 
0AE5 C000       213            push ar0
0AE7 A839       213            mov r0, bcd+1
0AE9 120253     213            lcall ?Display_BCD
0AEC D000       213            pop ar0 
0AEE C000       214            push ar0
0AF0 A838       214            mov r0, bcd+0
0AF2 120253     214            lcall ?Display_BCD
0AF5 D000       214            pop ar0  
0AF7 22         215       ret
0AF8            216   
0AF8            217   Timer1_ISR:
0AF8 C28F       218       clr TF1 ; Clear overflow flag
0AFA            219       
0AFA            220       ; Increment millisecond counter
0AFA 0544       221       inc Count1ms+0
0AFC E544       222       mov a, Count1ms+0
0AFE 7016       223       jnz Timer1_ISR_Done
0B00 0545       224       inc Count1ms+1
0B02            225       
0B02            226       ; If 1000ms has passed, increment seconds
0B02 E545       227       mov a, Count1ms+1
0B04 B4030F     228       cjne a, #high(1000), Timer1_ISR_Done
0B07 E544       229       mov a, Count1ms+0
0B09 B4E80A     230       cjne a, #low(1000), Timer1_ISR_Done
0B0C            231       
0B0C 754400     232       mov Count1ms+0,#0
0B0F 754500     233       mov Count1ms+1,#0
0B12 054A       234       inc seconds
0B14 D206       235       setb seconds_flag
0B16            236   
0B16            237   Timer1_ISR_Done:
0B16 D033       238            pop x+3
0B18 D032       239            pop x+2
0B1A D031       240            pop x+1
0B1C D030       241            pop x+0
0B1E D037       242            pop y+3
0B20 D036       243            pop y+2
0B22 D035       244            pop y+1
0B24 D034       245            pop y+0
0B26 D0D0       246            pop psw
0B28 D0E0       247            pop acc
0B2A 32         248            reti 
0B2B            249   
0B2B            250   Timer2_Init:
0B2B 75C800     251            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0B2E 75CDD7     252            mov TH2, #high(TIMER2_RELOAD)
0B31 75CC79     253            mov TL2, #low(TIMER2_RELOAD)
0B34            254            ; Set the reload value
0B34 75C980     255            mov T2MOD, #1000_0000b 
0B37            256            ;orl T2MOD, #0x80 ; Enable timer 2 autoreload this was it before
0B37 75CBD7     257            mov RCMP2H, #high(TIMER2_RELOAD)
0B3A 75CA79     258            mov RCMP2L, #low(TIMER2_RELOAD)
0B3D            259            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0B3D            260   ;        clr a
0B3D            261   ;        mov Count1ms+0, a
0B3D            262   ;        mov Count1ms+1, a
0B3D            263   ;        mov seconds, #0
0B3D            264   ;        clr seconds_flag
0B3D            265            ; Enable the timer and interrupts
0B3D            266   ;        orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0B3D D2CA       267       setb TR2  ; Enable timer 2
0B3F 22         268            ret
0B40            269   ;---------------------------------;
0B40            270   ; ISR for timer 2                 ;
0B40            271   ;---------------------------------;
0B40            272            
0B40            273   Timer2_ISR:
0B40 C2CF       274            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0B42            275            
0B42            276            ; The two registers used in the ISR must be saved in the stack
0B42 C0E0       277            push acc
0B44 C0D0       278            push psw
0B46 C034       279            push y+0
0B48 C035       280            push y+1
0B4A C036       281            push y+2
0B4C C037       282            push y+3
0B4E C030       283            push x+0
0B50 C031       284            push x+1
0B52 C032       285            push x+2
0B54 C033       286            push x+3
0B56            287            
0B56 0548       288       inc pwm_counter
0B58 C3         289            clr c
0B59 E549       290            mov a, pwm
0B5B 9548       291            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0B5D B3         292            cpl c
0B5E 9290       293            mov PWM_OUT, c
0B60            294            
0B60 E548       295            mov a, pwm_counter
0B62 B46403     296            cjne a, #100, Timer2_ISR_done
0B65 754800     297            mov pwm_counter, #0
0B68            298            ;inc seconds ; It is super easy to keep a seconds count here
0B68            299            ;setb seconds_flag
0B68            300      
0B68            301       ;inc seconds ; It is super easy to keep a seconds count here
0B68            302   
0B68            303   
0B68            304            ;increment second flag 
0B68            305   
0B68            306            ;mov a, seconds
0B68            307            ;add a, #1
0B68            308            ;da A
0B68            309            ;mov seconds, A
0B68            310   
0B68            311   
0B68            312   ;Inc_Done:
0B68            313            ; Check if second has passed
0B68            314   ;        mov a, Count1ms+0
0B68            315   ;        cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0B68            316   ;        mov a, Count1ms+1
0B68            317   ;        cjne a, #high(1000), Time_increment_done
0B68            318            
0B68            319            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0B68            320   ;        setb seconds_flag ; Let the main program know a second had passed
0B68            321            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0B68            322            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0B68            323   ;        clr a
0B68            324   ;        mov Count1ms+0, a
0B68            325   ;        mov Count1ms+1, a
0B68            326            ; Increment the time only when state flag is on
0B68            327            ;jnb state, Time_increment_done
0B68            328            
0B68            329   ;        mov a, sec
0B68            330   ;        add a, #0x01
0B68            331   ;        da a
0B68            332   ;        mov sec, a
0B68            333   ;        
0B68            334   ;        cjne a, #0x60, Time_increment_done
0B68            335   
0B68            336                    
0B68            337   Timer2_ISR_done:
0B68 D033       338            pop x+3
0B6A D032       339            pop x+2
0B6C D031       340            pop x+1
0B6E D030       341            pop x+0
0B70 D037       342            pop y+3
0B72 D036       343            pop y+2
0B74 D035       344            pop y+1
0B76 D034       345            pop y+0
0B78 D0D0       346            pop psw
0B7A D0E0       347            pop acc
0B7C 32         348            reti
0B7D            349   
0B7D            350   
0B7D            351   
0B7D            352   
0B7D            353   
0B7D            354   
0B7D            355   
0B7D            356   ADC_to_PB:
0B7D C0E0       357            push acc
0B7F 53E8F0     358            anl ADCCON0, #0xF0
0B82 43E800     359            orl ADCCON0, #0x00 ; Select AIN0
0B85            360            
0B85 C2EF       361            clr ADCF
0B87 D2EE       362            setb ADCS   ; ADC start trigger signal
0B89 30EFFD     363       jnb ADCF, $ ; Wait for conversion complete
0B8C            364   
0B8C D204       365            setb RST;PB7
0B8E D203       366            setb NXT;PB6
0B90 D202       367            setb UP;PB5
0B92 D201       368            setb DOWN;PB4
0B94 D200       369            setb S_S;PB3
0B96            370            ;setb PB2
0B96            371            ;setb PB1
0B96            372            ;setb PB0
0B96            373            
0B96            374            ; Check PB7
0B96            375   ;ADC_to_PB_L7:
0B96            376   ;        clr c
0B96            377   ;        mov a, ADCRH
0B96            378   ;        subb a, #0xf0
0B96            379   ;        jc ADC_to_PB_L6
0B96            380   ;        clr RST;PB7
0B96            381   ;        ret
0B96            382   ;
0B96            383   ;        ; Check PB6
0B96            384   ;ADC_to_PB_L6:
0B96            385   ;        clr c
0B96            386   ;        mov a, ADCRH
0B96            387   ;        subb a, #0xd0
0B96            388   ;        jc ADC_to_PB_L5
0B96            389   ;        clr NXT;PB6
0B96            390   ;        ret
0B96            391   
0B96            392            ; Check PB5
0B96            393   ADC_to_PB_L5:
0B96 C3         394            clr c
0B97 E5C3       395            mov a, ADCRH
0B99 94B0       396            subb a, #0xb0
0B9B 4005       397            jc ADC_to_PB_L4
0B9D C204       398            clr RST;PB5
0B9F D0E0       399            pop acc
0BA1 22         400            ret
0BA2            401   
0BA2            402            ; Check PB4
0BA2            403   ADC_to_PB_L4:
0BA2 C3         404            clr c
0BA3 E5C3       405            mov a, ADCRH
0BA5 9490       406            subb a, #0x90
0BA7 4005       407            jc ADC_to_PB_L3
0BA9 C203       408            clr NXT;PB4
0BAB D0E0       409            pop acc
0BAD 22         410            ret
0BAE            411   
0BAE            412            ; Check PB3
0BAE            413   ADC_to_PB_L3:
0BAE C3         414            clr c
0BAF E5C3       415            mov a, ADCRH
0BB1 9470       416            subb a, #0x70
0BB3 4005       417            jc ADC_to_PB_L2
0BB5 C202       418            clr UP;PB3
0BB7 D0E0       419            pop acc
0BB9 22         420            ret
0BBA            421   
0BBA            422            ; Check PB2
0BBA            423   ADC_to_PB_L2:
0BBA C3         424            clr c
0BBB E5C3       425            mov a, ADCRH
0BBD 9450       426            subb a, #0x50
0BBF 4005       427            jc ADC_to_PB_L1
0BC1 C201       428            clr DOWN
0BC3 D0E0       429            pop acc
0BC5 22         430            ret
0BC6            431   
0BC6            432            ; Check PB1
0BC6            433   ADC_to_PB_L1:
0BC6 C3         434            clr c
0BC7 E5C3       435            mov a, ADCRH
0BC9 9430       436            subb a, #0x30
0BCB 4005       437            jc ADC_to_PB_L0
0BCD C200       438            clr S_S
0BCF D0E0       439            pop acc
0BD1 22         440            ret
0BD2            441   
0BD2            442            ; Check PB0
0BD2            443   ADC_to_PB_L0:
0BD2 C3         444            clr c
0BD3 E5C3       445            mov a, ADCRH
0BD5 9410       446            subb a, #0x10
0BD7 4003       447            jc ADC_to_PB_Done
0BD9            448            ;clr PB0
0BD9 D0E0       449            pop acc
0BDB 22         450            ret
0BDC            451            
0BDC            452   ADC_to_PB_Done:
0BDC            453            ; No pusbutton pressed  
0BDC D0E0       454            pop acc
0BDE 22         455            ret
0BDF            456            
0BDF            457   main:
0BDF 75817F     458            mov sp, #0x7f
0BE2 12052C     459            lcall Temp_Init_All
0BE5 120A7F     460            lcall Init_All
0BE8 12020E     461       lcall LCD_4BIT
0BEB            462       
0BEB 120269     463       lcall state_init ;From State_Machine.inc
0BEE            464       
0BEE            465       ; initial messages in LCD
0BEE C0E0       466            push acc
0BF0 7401       466            mov a, #1
0BF2 14         466            dec a
0BF3 12024E     466            lcall ?Set_Cursor_1 ; Select column and row
0BF6 D0E0       466            pop acc
0BF8 C083       467            push dph
0BFA C082       467            push dpl
0BFC C0E0       467            push acc
0BFE 90002E     467            mov dptr, #Title
0C01 120241     467            lcall ?Send_Constant_String
0C04 D0E0       467            pop acc
0C06 D082       467            pop dpl
0C08 D083       467            pop dph
0C0A C0E0       468            push acc
0C0C 7401       468            mov a, #1
0C0E 14         468            dec a
0C0F 12024C     468            lcall ?Set_Cursor_2 ; Select column and row
0C12 D0E0       468            pop acc
0C14 C083       469            push dph
0C16 C082       469            push dpl
0C18 C0E0       469            push acc
0C1A 90003E     469            mov dptr, #blank
0C1D 120241     469            lcall ?Send_Constant_String
0C20 D0E0       469            pop acc
0C22 D082       469            pop dpl
0C24 D083       469            pop dph
0C26            470   
0C26 7AFA       471            mov R2, #250
0C28 120AD6     472            lcall waitms
0C2B            473            
0C2B            474   Forever:
0C2B            475            ; Wait 50 ms between readings
0C2B 7A32       476            mov R2, #50
0C2D 120AD6     477            lcall waitms
0C30            478   
0C30            479            ; output? 
0C30 300604     480            jnb seconds_flag, no_second
0C33 C206       481            clr seconds_flag
0C35 B295       482            cpl P1.5
0C37            483   
0C37            484   no_second:
0C37            485   
0C37 7A32       486            mov R2, #50
0C39 120AD6     487            lcall waitms
0C3C            488   
0C3C 020C3F     489            ljmp FSM_select
0C3F            490   
0C3F            491            ;Set_Cursor(2, 11)
0C3F            492            ;mov r0, #80
0C3F            493            ;mov x+0, r0
0C3F            494            ;mov x+1, #0 
0C3F            495            ;mov x+2, #0
0C3F            496            ;mov x+3, #0
0C3F            497            ;lcall hex2bcd
0C3F            498            ;lcall Display_formated_BCD
0C3F            499            
0C3F            500            ;check if reaches forever
0C3F            501            ;Set_Cursor(1, 1)
0C3F            502            ;Send_Constant_String(#forever_message)
0C3F            503            ;mov R2, #250
0C3F            504            ;lcall waitms
0C3F            505            ;ljmp FSM_select
0C3F            506   
0C3F            507   ;no_second:
0C3F            508   ;        ljmp Forever
0C3F            509   
0C3F            510   ;for testing since there's no other fsm right now
0C3F            511   
0C3F            512   
0C3F            513   ;begin select FSM
0C3F            514   FSM_select:
0C3F E53D       515            mov a, selecting_state
0C41            516   
0C41            517   select_wait:
0C41 B4004C     518            cjne a, #0, select_soak_time ;checks the state
0C44 C0E0       519            push acc
0C46 7401       519            mov a, #1
0C48 14         519            dec a
0C49 12024E     519            lcall ?Set_Cursor_1 ; Select column and row
0C4C D0E0       519            pop acc
0C4E C083       520            push dph
0C50 C082       520            push dpl
0C52 C0E0       520            push acc
0C54 90004F     520            mov dptr, #swait_message1
0C57 120241     520            lcall ?Send_Constant_String
0C5A D0E0       520            pop acc
0C5C D082       520            pop dpl
0C5E D083       520            pop dph
0C60 C0E0       521            push acc
0C62 7401       521            mov a, #1
0C64 14         521            dec a
0C65 12024C     521            lcall ?Set_Cursor_2 ; Select column and row
0C68 D0E0       521            pop acc
0C6A C083       522            push dph
0C6C C082       522            push dpl
0C6E C0E0       522            push acc
0C70 900060     522            mov dptr, #swait_message2
0C73 120241     522            lcall ?Send_Constant_String
0C76 D0E0       522            pop acc
0C78 D082       522            pop dpl
0C7A D083       522            pop dph
0C7C 7AFA       523            mov R2, #250
0C7E 120AD6     524            lcall waitms
0C81            525       ;lcall ADC_to_PB ;checks for button press
0C81 120E9F     526       lcall rst_check
0C84 120EAA     527       lcall nxt_check
0C87 120F6D     528       lcall s_s_check
0C8A 020C2B     529       ljmp forever ;i believe 
0C8D            530   
0C8D            531   select_soak_temp_ah:
0C8D 020D15     532            ljmp select_soak_temp
0C90            533   
0C90            534   select_soak_time:
0C90 B401FA     535            cjne a, #1, select_soak_temp_ah ;checks the state
0C93 C0E0       536            push acc
0C95 7401       536            mov a, #1
0C97 14         536            dec a
0C98 12024E     536            lcall ?Set_Cursor_1 ; Select column and row
0C9B D0E0       536            pop acc
0C9D C083       537            push dph
0C9F C082       537            push dpl
0CA1 C0E0       537            push acc
0CA3 900071     537            mov dptr, #sstime_message1
0CA6 120241     537            lcall ?Send_Constant_String
0CA9 D0E0       537            pop acc
0CAB D082       537            pop dpl
0CAD D083       537            pop dph
0CAF C0E0       538            push acc
0CB1 7401       538            mov a, #1
0CB3 14         538            dec a
0CB4 12024C     538            lcall ?Set_Cursor_2 ; Select column and row
0CB7 D0E0       538            pop acc
0CB9 C083       539            push dph
0CBB C082       539            push dpl
0CBD C0E0       539            push acc
0CBF 900082     539            mov dptr, #sstime_message2
0CC2 120241     539            lcall ?Send_Constant_String
0CC5 D0E0       539            pop acc
0CC7 D082       539            pop dpl
0CC9 D083       539            pop dph
0CCB            540       ;Set_Cursor(2, 11)
0CCB C005       541       push AR5  ;display the current soak_time
0CCD AD30       542       mov R5, x
0CCF 853F30     543       mov x+0, soak_time
0CD2 753100     544            mov x+1, #0
0CD5 753200     545            mov x+2, #0
0CD8 753300     546            mov x+3, #0
0CDB C0E0       547            push acc
0CDD 740B       547            mov a, #11
0CDF 14         547            dec a
0CE0 12024C     547            lcall ?Set_Cursor_2 ; Select column and row
0CE3 D0E0       547            pop acc
0CE5            548            ;Send_Constant_String(#its_works)
0CE5 1202BC     549       lcall hex2bcd
0CE8 120ADC     550       lcall Display_formated_BCD
0CEB 8D30       551       mov x, R5
0CED D005       552       pop AR5
0CEF            553       ;lcall ADC_to_PB ;checks for button press
0CEF 120E9F     554       lcall rst_check
0CF2 C003       555       push AR3 ;set the paramaters for up/down
0CF4 C004       556       push AR4
0CF6 C005       557       push AR5
0CF8 7B3C       558       mov R3, #0x3C ;min value allowed for soak time !check it please
0CFA 7C78       559       mov R4, #0x78 ;120  ;max value, !check it please, also is the dec? hex?
0CFC AD3F       560       mov R5, soak_time
0CFE 120EDD     561       lcall up_check
0D01 120F25     562       lcall down_check
0D04 8D3F       563       mov soak_time, R5
0D06 D005       564       pop AR5
0D08 D004       565       pop AR4
0D0A D003       566       pop AR3  ;am i doing this right?
0D0C 120F6D     567       lcall s_s_check
0D0F 120EAA     568       lcall nxt_check
0D12 020C2B     569       ljmp forever ;i believe 
0D15            570   
0D15            571   select_soak_temp:
0D15 B40203     572            cjne a, #2, $+6 ;checks the state
0D18 020D1E     573            ljmp $+6
0D1B 020DAA     574            ljmp select_reflow_time
0D1E C0E0       575            push acc
0D20 7401       575            mov a, #1
0D22 14         575            dec a
0D23 12024E     575            lcall ?Set_Cursor_1 ; Select column and row
0D26 D0E0       575            pop acc
0D28 C083       576            push dph
0D2A C082       576            push dpl
0D2C C0E0       576            push acc
0D2E 900093     576            mov dptr, #sstemp_message1
0D31 120241     576            lcall ?Send_Constant_String
0D34 D0E0       576            pop acc
0D36 D082       576            pop dpl
0D38 D083       576            pop dph
0D3A C0E0       577            push acc
0D3C 7401       577            mov a, #1
0D3E 14         577            dec a
0D3F 12024C     577            lcall ?Set_Cursor_2 ; Select column and row
0D42 D0E0       577            pop acc
0D44 C083       578            push dph
0D46 C082       578            push dpl
0D48 C0E0       578            push acc
0D4A 9000A4     578            mov dptr, #sstemp_message2
0D4D 120241     578            lcall ?Send_Constant_String
0D50 D0E0       578            pop acc
0D52 D082       578            pop dpl
0D54 D083       578            pop dph
0D56 C0E0       579            push acc
0D58 740B       579            mov a, #11
0D5A 14         579            dec a
0D5B 12024C     579            lcall ?Set_Cursor_2 ; Select column and row
0D5E D0E0       579            pop acc
0D60 C005       580       push AR5  ;display current soak temp
0D62 C030       581            push x+0
0D64 C031       581            push x+1
0D66 C032       581            push x+2
0D68 C033       581            push x+3
0D6A 854030     582            mov x+0, soak_temp
0D6D 753100     583            mov x+1, #0
0D70 753200     584            mov x+2, #0
0D73 753300     585            mov x+3, #0
0D76 1202BC     586       lcall hex2bcd
0D79 120ADC     587       lcall Display_formated_BCD
0D7C            588       ;mov x, R5
0D7C D030       589            pop x+0
0D7E D031       589            pop x+1
0D80 D032       589            pop x+2
0D82 D033       589            pop x+3
0D84            590       ;lcall ADC_to_PB ;checks for button press
0D84 120E9F     591       lcall rst_check
0D87 C003       592       push AR3 ;set the paramaters for up/down
0D89 C004       593       push AR4
0D8B C005       594       push AR5
0D8D 7B96       595       mov R3, #0x96 ;min value allowed !check it please (150 decimal)
0D8F 7CC8       596       mov R4, #0xC8 ;max value, !check it please, also is the dec? hex? (200 decimal)
0D91 AD40       597       mov R5, soak_temp
0D93 120EDD     598       lcall up_check
0D96 120F25     599       lcall down_check
0D99 8D40       600       mov soak_temp, R5
0D9B D005       601       pop AR5
0D9D D004       602       pop AR4
0D9F D003       603       pop AR3  ;am i doing this right?
0DA1 120F6D     604       lcall s_s_check
0DA4 120EAA     605       lcall nxt_check
0DA7 020C2B     606       ljmp forever ;i believe 
0DAA            607   
0DAA            608   select_reflow_time:
0DAA B40379     609            cjne a, #3, select_reflow_temp ;checks the state
0DAD C0E0       610            push acc
0DAF 7401       610            mov a, #1
0DB1 14         610            dec a
0DB2 12024E     610            lcall ?Set_Cursor_1 ; Select column and row
0DB5 D0E0       610            pop acc
0DB7 C083       611            push dph
0DB9 C082       611            push dpl
0DBB C0E0       611            push acc
0DBD 9000B5     611            mov dptr, #srtime_message1
0DC0 120241     611            lcall ?Send_Constant_String
0DC3 D0E0       611            pop acc
0DC5 D082       611            pop dpl
0DC7 D083       611            pop dph
0DC9 C0E0       612            push acc
0DCB 7401       612            mov a, #1
0DCD 14         612            dec a
0DCE 12024C     612            lcall ?Set_Cursor_2 ; Select column and row
0DD1 D0E0       612            pop acc
0DD3 C083       613            push dph
0DD5 C082       613            push dpl
0DD7 C0E0       613            push acc
0DD9 9000C6     613            mov dptr, #srtime_message2
0DDC 120241     613            lcall ?Send_Constant_String
0DDF D0E0       613            pop acc
0DE1 D082       613            pop dpl
0DE3 D083       613            pop dph
0DE5 C0E0       614            push acc
0DE7 740B       614            mov a, #11
0DE9 14         614            dec a
0DEA 12024C     614            lcall ?Set_Cursor_2 ; Select column and row
0DED D0E0       614            pop acc
0DEF C005       615       push AR5  ;display current reflow time
0DF1 AD30       616       mov R5, x
0DF3 854130     617       mov x, reflow_time
0DF6 1202BC     618       lcall hex2bcd
0DF9 120ADC     619       lcall Display_formated_BCD
0DFC 8D30       620       mov x, R5
0DFE D005       621       pop AR5
0E00            622       ;lcall ADC_to_PB ;checks for button press
0E00 120E9F     623       lcall rst_check
0E03 C003       624       push AR3 ;set the paramaters for up/down
0E05 C004       625       push AR4
0E07 C005       626       push AR5
0E09 7B00       627       mov R3, #0x00 ;45 min value allowed !check it please
0E0B 7C2D       628       mov R4, #0x2D ;75 max value, !check it please, also is the dec? hex?
0E0D AD41       629       mov R5, reflow_time
0E0F 120EDD     630       lcall up_check
0E12 120F25     631       lcall down_check
0E15 8D41       632       mov reflow_time, R5
0E17 D005       633       pop AR5
0E19 D004       634       pop AR4
0E1B D003       635       pop AR3  ;am i doing this right?
0E1D 120F6D     636       lcall s_s_check
0E20 120EAA     637       lcall nxt_check
0E23 020C2B     638       ljmp forever ;i believe 
0E26            639   
0E26            640   select_reflow_temp:
0E26            641            ;shouldn't need to check the state
0E26 C0E0       642            push acc
0E28 7401       642            mov a, #1
0E2A 14         642            dec a
0E2B 12024E     642            lcall ?Set_Cursor_1 ; Select column and row
0E2E D0E0       642            pop acc
0E30 C083       643            push dph
0E32 C082       643            push dpl
0E34 C0E0       643            push acc
0E36 9000D7     643            mov dptr, #srtemp_message1
0E39 120241     643            lcall ?Send_Constant_String
0E3C D0E0       643            pop acc
0E3E D082       643            pop dpl
0E40 D083       643            pop dph
0E42 C0E0       644            push acc
0E44 7401       644            mov a, #1
0E46 14         644            dec a
0E47 12024C     644            lcall ?Set_Cursor_2 ; Select column and row
0E4A D0E0       644            pop acc
0E4C C083       645            push dph
0E4E C082       645            push dpl
0E50 C0E0       645            push acc
0E52 9000E8     645            mov dptr, #srtemp_message2
0E55 120241     645            lcall ?Send_Constant_String
0E58 D0E0       645            pop acc
0E5A D082       645            pop dpl
0E5C D083       645            pop dph
0E5E C0E0       646            push acc
0E60 740B       646            mov a, #11
0E62 14         646            dec a
0E63 12024C     646            lcall ?Set_Cursor_2 ; Select column and row
0E66 D0E0       646            pop acc
0E68 C005       647       push AR5  ;display current reflow temp
0E6A AD30       648       mov R5, x
0E6C 854230     649       mov x, reflow_temp
0E6F 1202BC     650       lcall hex2bcd
0E72 120ADC     651       lcall Display_formated_BCD
0E75 8D30       652       mov x, R5
0E77 D005       653       pop AR5
0E79            654       ;lcall ADC_to_PB ;checks for button press
0E79 120E9F     655       lcall rst_check
0E7C C003       656       push AR3  ;set the paramaters for up/down
0E7E C004       657       push AR4
0E80 C005       658       push AR5
0E82 7BD9       659       mov R3, #0xD9 ;217 DEC ;min value allowed !check it please
0E84 7CF0       660       mov R4, #0xF0 ; 255 DEC ;max value, !check it please, also is the dec? hex?
0E86 AD42       661       mov R5, reflow_temp
0E88 120EDD     662       lcall up_check
0E8B 120F25     663       lcall down_check
0E8E 8D42       664       mov reflow_temp, R5
0E90 D005       665       pop AR5
0E92 D004       666       pop AR4
0E94 D003       667       pop AR3  ;am i doing this right?
0E96 120F6D     668       lcall s_s_check
0E99 120EAA     669       lcall nxt_check
0E9C 020C2B     670       ljmp forever ;i believe 
0E9F            671   
0E9F            672   ;maybe make these macros :(
0E9F            673   ;use R3 & R4 & R5 as parameters
0E9F            674   rst_check:
0E9F 120B7D     675            lcall ADC_to_PB
0EA2 A204       676            mov c, RST
0EA4 5001       677       jnc rst_check_0 ;!could be jc
0EA6 22         678       ret
0EA7            679   rst_check_0:
0EA7 020279     680       ljmp reset_state ;or whatever it's called, wait state of oven fsm
0EAA            681   
0EAA            682   nxt_check:
0EAA 120B7D     683            lcall ADC_to_PB
0EAD A203       684            mov c, NXT
0EAF 5001       685       jnc next_check_1 
0EB1 22         686            ret
0EB2            687   next_check_1: 
0EB2            688       ;load_x(selecting_state)
0EB2            689       ;load_y(4)
0EB2 853D30     690            mov x, selecting_state
0EB5 753100     691            mov x+1, #0
0EB8 753200     692            mov x+2, #0
0EBB 753300     693            mov x+3, #0
0EBE 753404     694            mov y, #0x04
0EC1 753500     695            mov y+1, #0
0EC4 753600     696            mov y+2, #0
0EC7 753700     697            mov y+3, #0
0ECA 1203FC     698       lcall x_eq_y
0ECD D3         699            setb c
0ECE 200507     700            jb mf, next_check_2
0ED1 E53D       701       mov a, selecting_state 
0ED3 3400       702       addc a, #0 ;uh
0ED5 F53D       703       mov selecting_state, a
0ED7 22         704       ret
0ED8            705   next_check_2:
0ED8 C3         706            clr c
0ED9 753D00     707            mov selecting_state, #0 ;can't go above 4 (there are 5 states)
0EDC            708   
0EDC 22         709            ret
0EDD            710   
0EDD            711   up_check: ;R4 max
0EDD 120B7D     712            lcall ADC_to_PB
0EE0 A202       713            mov c, UP
0EE2 5001       714            jnc up_check_1
0EE4 22         715            ret 
0EE5            716   up_check_1:
0EE5 8C30       717            mov x, R4
0EE7 753100     718            mov x+1, #0
0EEA 753200     719            mov x+2, #0
0EED 753300     720            mov x+3, #0
0EF0 8D34       721            mov y, R5
0EF2 753500     722            mov y+1, #0
0EF5 753600     723            mov y+2, #0
0EF8 753700     724            mov y+3, #0
0EFB 1203E0     725            lcall x_gt_y ;max > value
0EFE D3         726            setb c
0EFF 300505     727            jnb mf, up_check_2
0F02 ED         728            mov a, R5
0F03 3400       729            addc a, #0 ;dec? hex?
0F05 FD         730            mov R5, a
0F06 22         731            ret
0F07            732   up_check_2:
0F07 C3         733            clr c
0F08 C0E0       734            push acc
0F0A 740B       734            mov a, #11
0F0C 14         734            dec a
0F0D 12024C     734            lcall ?Set_Cursor_2 ; Select column and row
0F10 D0E0       734            pop acc
0F12 C083       735            push dph
0F14 C082       735            push dpl
0F16 C0E0       735            push acc
0F18 9000F9     735            mov dptr, #too_high_message
0F1B 120241     735            lcall ?Send_Constant_String
0F1E D0E0       735            pop acc
0F20 D082       735            pop dpl
0F22 D083       735            pop dph
0F24 22         736            ret
0F25            737   
0F25            738   down_check: ;R3 min
0F25 120B7D     739            lcall ADC_to_PB
0F28 A201       740            mov c, DOWN
0F2A 5001       741            jnc down_check_1
0F2C 22         742            ret
0F2D            743   down_check_1:
0F2D 8B30       744            mov x, R3
0F2F 753100     745            mov x+1, #0
0F32 753200     746            mov x+2, #0
0F35 753300     747            mov x+3, #0
0F38 8D34       748            mov y, R5
0F3A 753500     749            mov y+1, #0
0F3D 753600     750            mov y+2, #0
0F40 753700     751            mov y+3, #0
0F43 1203C4     752            lcall x_lt_y ;min < value
0F46 D3         753            setb c
0F47 300505     754            jnb mf, down_check_2
0F4A ED         755            mov a, R5
0F4B 9400       756            subb a, #0 ;dec? hex?
0F4D FD         757            mov R5, a
0F4E 22         758            ret
0F4F            759   down_check_2:
0F4F C3         760            clr c
0F50 C0E0       761            push acc
0F52 740B       761            mov a, #11
0F54 14         761            dec a
0F55 12024C     761            lcall ?Set_Cursor_2 ; Select column and row
0F58 D0E0       761            pop acc
0F5A C083       762            push dph
0F5C C082       762            push dpl
0F5E C0E0       762            push acc
0F60 900103     762            mov dptr, #too_low_message
0F63 120241     762            lcall ?Send_Constant_String
0F66 D0E0       762            pop acc
0F68 D082       762            pop dpl
0F6A D083       762            pop dph
0F6C 22         763            ret
0F6D            764   
0F6D            765   s_s_check:
0F6D 120B7D     766            lcall ADC_to_PB
0F70 A200       767            mov c, S_S
0F72 5001       768            jnc s_s_check_done ;!could be jb
0F74 22         769            ret
0F75            770   s_s_check_done:
0F75 020761     771            ljmp FSM_Init ;or whatever it's called, 1st state of oven FSM
0F78            772   
0F78            773   END
