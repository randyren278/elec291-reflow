0000              1   ;please work
0000              2   
0000              3   ;with 5 adc push buttons
0000              4   ;to think about:
0000              5            ;adding another state for when start is pressed so that in forever if it gets sent back to FSM_select
0000              6            ;it will know not to ask for input/go through it
0000              7            ;making the checks into macros
0000              8   
0000              9   ;button functions: rst, next, up, down, start/stop
0000             10   ;display which you're in 
0000             11   ;start-> in the selecting fsm
0000             12   ;stop-> after reset_state in the oven fsm
0000             13   
0000             14   ; 76E003 ADC_Pushbuttons.asm: Reads push buttons using the ADC, AIN0 in P1.7
0000             15   
                 17   $LIST
0000             19   
0000             20   ;  N76E003 pinout:
0000             21   ;                               -------
0000             22   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             23   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             24   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             25   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             26   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             27   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             28   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             29   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             30   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             31   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             32   ;                               -------
0000             33   ;
0000             34   
0000             35   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             36   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             37   TIMER1_RATE         EQU 100      ; 100Hz or 10ms
0000             38   TIMER1_RELOAD       EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 1 input divide to 16 in T2MOD
0000             39   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             40   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             41   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             42   
0000             43   ORG 0x0000
0000 020B4D      44            ljmp main
002B             45   ORG 0x002B
002B 020A75      46            ljmp Timer2_ISR
002E             47   
002E             48   ;                     1234567890123456    <- This helps determine the location of the counter
002E 20206865    49   title:            db '  here we go!  ', 0
     72652077
     6520676F
     21202000
003E 20202020    50   blank:            db '                ', 0
     20202020
     20202020
     20202020
     00
004F 53657420    51   swait_message1:   db 'Set your values ', 0   ;s->select fsm, wait->state
     796F7572
     2076616C
     75657320
     00
0060 50726573    52   swait_message2:   db 'Press next      ', 0
     73206E65
     78742020
     20202020
     00
0071 53656C65    53   sstime_message1:  db 'Select soak time', 0   ;s->soak
     63742073
     6F616B20
     74696D65
     00
0082 536F616B    54   sstime_message2:  db 'Soak time:      ', 0
     2074696D
     653A2020
     20202020
     00
0093 53656C65    55   sstemp_message1:  db 'Select soak temp', 0   ;s->soak
     63742073
     6F616B20
     74656D70
     00
00A4 536F616B    56   sstemp_message2:  db 'Soak temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00B5 53656C65    57   srtime_message1:  db 'Select refl time', 0   ;r->reflow
     63742072
     65666C20
     74696D65
     00
00C6 5265666C    58   srtime_message2:  db 'Refl time:      ', 0
     2074696D
     653A2020
     20202020
     00
00D7 53656C65    59   srtemp_message1:  db 'Select refl temp', 0   ;r->reflow
     63742072
     65666C20
     74656D70
     00
00E8 5265666C    60   srtemp_message2:  db 'Refl temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00F9 6D617821    61   too_high_message: db 'max!     ', 0
     20202020
     2000
0103 6D696E21    62   too_low_message:  db 'min!     ', 0
     20202020
     2000
010D 68656C6C    63   forever_message:  db 'hello please', 0
     6F20706C
     65617365
     00
011A 64696500    64   its_works:        db 'die',0
011E 646F6E65    65   done_message:      db 'done!',0
     2100
0124 73746F70    66   stop_message:      db 'stopped!',0
     70656421
     00
012D             67                                               ;1234567890123456
012D 4F76656E    68   oven_fsm_message_0: db 'Oven State 0!   ',0
     20537461
     74652030
     21202020
     00
013E 4F76656E    69   oven_fsm_message_1: db 'Oven State 1!   ',0
     20537461
     74652031
     21202020
     00
014F 4F76656E    70   oven_fsm_message_2: db 'Oven State 2!   ',0
     20537461
     74652032
     21202020
     00
0160 4F76656E    71   oven_fsm_message_3: db 'Oven State 3!   ',0
     20537461
     74652033
     21202020
     00
0171 4F76656E    72   oven_fsm_message_4: db 'Oven State 4!   ',0
     20537461
     74652034
     21202020
     00
0182 4F76656E    73   oven_fsm_message_5: db 'Oven State 5!   ',0
     20537461
     74652035
     21202020
     00
0193             74   ;                                                   1234567890123456
0193 53657474    75   reset_state_message:   db 'Settings Reset! ', 0 ;for testing
     696E6773
     20526573
     65742120
     00
01A4 73746174    76   state1_message:   db 'state1          ', 0 ;for testing
     65312020
     20202020
     20202020
     00
01B5             77   
01B5             78   cseg
01B5             79   ; These 'equ' must match the hardware wiring
01B5             80   LCD_RS equ P1.3
01B5             81   LCD_E  equ P1.4
01B5             82   LCD_D4 equ P0.0
01B5             83   LCD_D5 equ P0.1
01B5             84   LCD_D6 equ P0.2
01B5             85   LCD_D7 equ P0.3
01B5             86   SOUND_OUT equ P1.5
01B5             87   PWM_OUT    EQU P1.0 ; Logic 1=oven on
01B5             88   
                 91   ;                     1234567890123456    <- This helps determine the location of the counte$LIST
02BC             93   
0000             94   BSEG
0000             95   ; These eight bit variables store the value of the pushbuttons after calling 'ADC_to_PB' below
0000             96   ;PB0: dbit 1 
0000             97   ;PB1: dbit 1     pretty sure left-right is 7-0
0000             98   ;PB2: dbit 1
0000             99   S_S: dbit 1 ;PB3
0001            100   DOWN: dbit 1 ;PB4
0002            101   UP: dbit 1 ;PB5
0003            102   NXT: dbit 1 ;PB6
0004            103   RST: dbit 1 ;PB7
0005            104   mf: dbit 1
0006            105   seconds_flag: dbit 1
0007            106   s_flag: dbit 1 ; set to 1 every time a second has passed
0008            107   
0008            108   ;TODO: check if one is enough
0030            109   DSEG at 30H
0030            110   x: ds 4
0034            111   y: ds 4
0038            112   BCD: ds 5
003D            113   selecting_state: ds 1
003E            114   oven_state: ds 1
003F            115   soak_time: ds 2
0041            116   soak_temp: ds 2
0043            117   reflow_time: ds 2
0045            118   reflow_temp: ds 2
0047            119   Count1ms:     ds 2 
0049            120   sec: ds 1
004A            121   temp: ds 1
004B            122   pwm_counter:  ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
004C            123   pwm:          ds 1 ; pwm percentage
004D            124   seconds:      ds 1 ; a seconds counter attached to Timer 2 ISR
004E            125   
                546   $LIST
                129   $LIST
09DD            131   
09DD            132   CSEG
09DD            133   Init_All:
09DD            134            ; Configure all the pins for biderectional I/O
09DD 75AC00     135            mov     P3M1, #0x00
09E0 75AD00     136            mov     P3M2, #0x00
09E3 75B300     137            mov     P1M1, #0x00
09E6 75B400     138            mov     P1M2, #0x00
09E9 75B100     139            mov     P0M1, #0x00
09EC 75B200     140            mov     P0M2, #0x00
09EF            141            
09EF 438E10     142            orl     CKCON, #0x10 ; CLK is the input for timer 1
09F2 438780     143            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
09F5 759852     144            mov     SCON, #0x52
09F8 53C4DF     145            anl     T3CON, #0b11011111
09FB 53890F     146            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
09FE 438920     147            orl     TMOD, #0x20 ; Timer 1 Mode 2
0A01            148            
0A01            149            ; Using timer 0 for delay functions.  Initialize here:
0A01 C28C       150            clr     TR0 ; Stop timer 0
0A03 438E08     151            orl     CKCON,#0x08 ; CLK is the input for timer 0
0A06 5389F0     152            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0A09 438901     153            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0A0C            154            
0A0C            155            ; Initialize and start the ADC:
0A0C            156            
0A0C            157            ; AIN0 is connected to P1.7.  Configure P1.7 as input.
0A0C 43B380     158            orl     P1M1, #0b10000000
0A0F 53B47F     159            anl     P1M2, #0b01111111
0A12            160            
0A12            161            ; AINDIDS select if some pins are analog inputs or digital I/O:
0A12 75F600     162            mov AINDIDS, #0x00 ; Disable all analog inputs
0A15 43F601     163            orl AINDIDS, #0b00000001 ; Using AIN0
0A18 43E101     164            orl ADCCON1, #0x01 ; Enable ADC
0A1B            165   
0A1B            166            ; timer 2 ?? 
0A1B 120A53     167            lcall Timer2_Init
0A1E D2AF       168            setb EA
0A20            169   
0A20            170            
0A20 22         171            ret
0A21            172            
0A21            173   wait_1ms:
0A21 C28C       174            clr     TR0 ; Stop timer 0
0A23 C28D       175            clr     TF0 ; Clear overflow flag
0A25 758CBF     176            mov     TH0, #high(TIMER0_RELOAD_1MS)
0A28 758A28     177            mov     TL0,#low(TIMER0_RELOAD_1MS)
0A2B D28C       178            setb TR0
0A2D 308DFD     179            jnb     TF0, $ ; Wait for overflow
0A30 22         180            ret
0A31            181   
0A31            182   ; Wait the number of miliseconds in R2
0A31            183   waitms:
0A31 120A21     184            lcall wait_1ms
0A34 DAFB       185            djnz R2, waitms
0A36 22         186            ret
0A37            187   
0A37            188   ;set cursor before, also might have to change format     
0A37            189   Display_formated_BCD:  
0A37            190       ;Display_BCD(bcd+4) 
0A37            191       ;Display_BCD(bcd+3) 
0A37 C000       192            push ar0
0A39 A83A       192            mov r0, bcd+2
0A3B 120253     192            lcall ?Display_BCD
0A3E D000       192            pop ar0
0A40            192    
0A40 C000       193            push ar0
0A42 A839       193            mov r0, bcd+1
0A44 120253     193            lcall ?Display_BCD
0A47 D000       193            pop ar0 
0A49 C000       194            push ar0
0A4B A838       194            mov r0, bcd+0
0A4D 120253     194            lcall ?Display_BCD
0A50 D000       194            pop ar0  
0A52 22         195       ret
0A53            196   
0A53            197   Timer2_Init:
0A53 75C800     198            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0A56 75CDBF     199            mov TH2, #high(TIMER2_RELOAD)
0A59 75CC28     200            mov TL2, #low(TIMER2_RELOAD)
0A5C            201            ; Set the reload value
0A5C 75C980     202            mov T2MOD, #1000_0000b 
0A5F            203            ;orl T2MOD, #0x80 ; Enable timer 2 autoreload this was it before
0A5F 75CBBF     204            mov RCMP2H, #high(TIMER2_RELOAD)
0A62 75CA28     205            mov RCMP2L, #low(TIMER2_RELOAD)
0A65            206            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0A65 E4         207            clr a
0A66 F547       208            mov Count1ms+0, a
0A68 F548       209            mov Count1ms+1, a
0A6A 754900     210            mov sec, #0
0A6D C206       211            clr seconds_flag
0A6F            212            ; Enable the timer and interrupts
0A6F 439B80     213            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0A72 D2CA       214       setb TR2  ; Enable timer 2
0A74 22         215            ret
0A75            216   ;---------------------------------;
0A75            217   ; ISR for timer 2                 ;
0A75            218   ;---------------------------------;
0A75            219   Timer2_ISR:
0A75 C2CF       220            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0A77            221            
0A77            222            ; The two registers used in the ISR must be saved in the stack
0A77 C0E0       223            push acc
0A79 C0D0       224            push psw
0A7B C034       225            push y+0
0A7D C035       226            push y+1
0A7F C036       227            push y+2
0A81 C037       228            push y+3
0A83 C030       229            push x+0
0A85 C031       230            push x+1
0A87 C032       231            push x+2
0A89 C033       232            push x+3
0A8B            233            
0A8B            234            ; Increment the 16-bit one mili second counter
0A8B 0547       235            inc Count1ms+0    ; Increment the low 8-bits first
0A8D E547       236            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0A8F 7002       237            jnz Inc_Done_randys_version
0A91 0548       238            inc Count1ms+1
0A93            239   
0A93            240   Inc_Done_randys_version:
0A93            241   
0A93            242            ; CODE TO MAKE THE PWM WORK
0A93 C3         243            clr c
0A94 75304C     244            mov x+0, #low (pwm % 0x10000) 
0A97 753100     244            mov x+1, #high(pwm % 0x10000) 
0A9A 753200     244            mov x+2, #low (pwm / 0x10000) 
0A9D 753300     244            mov x+3, #high(pwm / 0x10000) 
0AA0 75340A     245            mov y+0, #low (10 % 0x10000) 
0AA3 753500     245            mov y+1, #high(10 % 0x10000) 
0AA6 753600     245            mov y+2, #low (10 / 0x10000) 
0AA9 753700     245            mov y+3, #high(10 / 0x10000) 
0AAC 120436     246            lcall mul32
0AAF C3         247            clr c
0AB0 E530       248            mov a, x+0
0AB2 9547       249            subb a, Count1ms+0
0AB4 5005       250            jnc pwm_output
0AB6 C3         251            clr c 
0AB7 E531       252            mov a, x+1
0AB9 9548       253            subb a, Count1ms+1 ; If pwm_counter <= pwm then c=1
0ABB            254   pwm_output:
0ABB B3         255            cpl c
0ABC 9290       256            mov PWM_OUT, c
0ABE            257   
0ABE            258            ;check if 1000 ms has passed 
0ABE E547       259            mov a, Count1ms+0
0AC0 B4E813     260            cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0AC3 E548       261            mov a, Count1ms+1
0AC5 B4030E     262            cjne a, #high(1000), Time_increment_done
0AC8            263   
0AC8            264            ; if1000 ms has passed 
0AC8            265   
0AC8 E4         266            clr A
0AC9 F547       267            mov Count1ms+0, A
0ACB F548       268            mov Count1ms+1, A
0ACD D206       269            setb seconds_flag
0ACF            270   
0ACF            271            ;increment second flag 
0ACF            272   
0ACF E549       273            mov a, sec
0AD1 2401       274            add a, #1
0AD3 D4         275            da A
0AD4 F549       276            mov sec, A
0AD6            277   
0AD6            278   
0AD6            279   ;Inc_Done:
0AD6            280            ; Check if second has passed
0AD6            281   ;        mov a, Count1ms+0
0AD6            282   ;        cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0AD6            283   ;        mov a, Count1ms+1
0AD6            284   ;        cjne a, #high(1000), Time_increment_done
0AD6            285            
0AD6            286            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0AD6            287   ;        setb seconds_flag ; Let the main program know a second had passed
0AD6            288            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0AD6            289            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0AD6            290   ;        clr a
0AD6            291   ;        mov Count1ms+0, a
0AD6            292   ;        mov Count1ms+1, a
0AD6            293            ; Increment the time only when state flag is on
0AD6            294            ;jnb state, Time_increment_done
0AD6            295            
0AD6            296   ;        mov a, sec
0AD6            297   ;        add a, #0x01
0AD6            298   ;        da a
0AD6            299   ;        mov sec, a
0AD6            300   ;        
0AD6            301   ;        cjne a, #0x60, Time_increment_done
0AD6            302   
0AD6            303                    
0AD6            304   Time_increment_done:
0AD6 D033       305            pop x+3
0AD8 D032       306            pop x+2
0ADA D031       307            pop x+1
0ADC D030       308            pop x+0
0ADE D037       309            pop y+3
0AE0 D036       310            pop y+2
0AE2 D035       311            pop y+1
0AE4 D034       312            pop y+0
0AE6 D0D0       313            pop psw
0AE8 D0E0       314            pop acc
0AEA 32         315            reti
0AEB            316   
0AEB            317   
0AEB            318   
0AEB            319   
0AEB            320   
0AEB            321   
0AEB            322   
0AEB            323   ADC_to_PB:
0AEB C0E0       324            push acc
0AED 53E8F0     325            anl ADCCON0, #0xF0
0AF0 43E800     326            orl ADCCON0, #0x00 ; Select AIN0
0AF3            327            
0AF3 C2EF       328            clr ADCF
0AF5 D2EE       329            setb ADCS   ; ADC start trigger signal
0AF7 30EFFD     330       jnb ADCF, $ ; Wait for conversion complete
0AFA            331   
0AFA D204       332            setb RST;PB7
0AFC D203       333            setb NXT;PB6
0AFE D202       334            setb UP;PB5
0B00 D201       335            setb DOWN;PB4
0B02 D200       336            setb S_S;PB3
0B04            337            ;setb PB2
0B04            338            ;setb PB1
0B04            339            ;setb PB0
0B04            340            
0B04            341            ; Check PB7
0B04            342   ;ADC_to_PB_L7:
0B04            343   ;        clr c
0B04            344   ;        mov a, ADCRH
0B04            345   ;        subb a, #0xf0
0B04            346   ;        jc ADC_to_PB_L6
0B04            347   ;        clr RST;PB7
0B04            348   ;        ret
0B04            349   ;
0B04            350   ;        ; Check PB6
0B04            351   ;ADC_to_PB_L6:
0B04            352   ;        clr c
0B04            353   ;        mov a, ADCRH
0B04            354   ;        subb a, #0xd0
0B04            355   ;        jc ADC_to_PB_L5
0B04            356   ;        clr NXT;PB6
0B04            357   ;        ret
0B04            358   
0B04            359            ; Check PB5
0B04            360   ADC_to_PB_L5:
0B04 C3         361            clr c
0B05 E5C3       362            mov a, ADCRH
0B07 94B0       363            subb a, #0xb0
0B09 4005       364            jc ADC_to_PB_L4
0B0B C204       365            clr RST;PB5
0B0D D0E0       366            pop acc
0B0F 22         367            ret
0B10            368   
0B10            369            ; Check PB4
0B10            370   ADC_to_PB_L4:
0B10 C3         371            clr c
0B11 E5C3       372            mov a, ADCRH
0B13 9490       373            subb a, #0x90
0B15 4005       374            jc ADC_to_PB_L3
0B17 C203       375            clr NXT;PB4
0B19 D0E0       376            pop acc
0B1B 22         377            ret
0B1C            378   
0B1C            379            ; Check PB3
0B1C            380   ADC_to_PB_L3:
0B1C C3         381            clr c
0B1D E5C3       382            mov a, ADCRH
0B1F 9470       383            subb a, #0x70
0B21 4005       384            jc ADC_to_PB_L2
0B23 C202       385            clr UP;PB3
0B25 D0E0       386            pop acc
0B27 22         387            ret
0B28            388   
0B28            389            ; Check PB2
0B28            390   ADC_to_PB_L2:
0B28 C3         391            clr c
0B29 E5C3       392            mov a, ADCRH
0B2B 9450       393            subb a, #0x50
0B2D 4005       394            jc ADC_to_PB_L1
0B2F C201       395            clr DOWN
0B31 D0E0       396            pop acc
0B33 22         397            ret
0B34            398   
0B34            399            ; Check PB1
0B34            400   ADC_to_PB_L1:
0B34 C3         401            clr c
0B35 E5C3       402            mov a, ADCRH
0B37 9430       403            subb a, #0x30
0B39 4005       404            jc ADC_to_PB_L0
0B3B C200       405            clr S_S
0B3D D0E0       406            pop acc
0B3F 22         407            ret
0B40            408   
0B40            409            ; Check PB0
0B40            410   ADC_to_PB_L0:
0B40 C3         411            clr c
0B41 E5C3       412            mov a, ADCRH
0B43 9410       413            subb a, #0x10
0B45 4003       414            jc ADC_to_PB_Done
0B47            415            ;clr PB0
0B47 D0E0       416            pop acc
0B49 22         417            ret
0B4A            418            
0B4A            419   ADC_to_PB_Done:
0B4A            420            ; No pusbutton pressed  
0B4A D0E0       421            pop acc
0B4C 22         422            ret
0B4D            423            
0B4D            424   main:
0B4D 75817F     425            mov sp, #0x7f
0B50 12052C     426            lcall Temp_Init_All
0B53 1209DD     427            lcall Init_All
0B56 12020E     428       lcall LCD_4BIT
0B59            429       
0B59 120269     430       lcall state_init ;From State_Machine.inc
0B5C            431       
0B5C            432       ; initial messages in LCD
0B5C C0E0       433            push acc
0B5E 7401       433            mov a, #1
0B60 14         433            dec a
0B61 12024E     433            lcall ?Set_Cursor_1 ; Select column and row
0B64 D0E0       433            pop acc
0B66 C083       434            push dph
0B68 C082       434            push dpl
0B6A C0E0       434            push acc
0B6C 90002E     434            mov dptr, #Title
0B6F 120241     434            lcall ?Send_Constant_String
0B72 D0E0       434            pop acc
0B74 D082       434            pop dpl
0B76 D083       434            pop dph
0B78 C0E0       435            push acc
0B7A 7401       435            mov a, #1
0B7C 14         435            dec a
0B7D 12024C     435            lcall ?Set_Cursor_2 ; Select column and row
0B80 D0E0       435            pop acc
0B82 C083       436            push dph
0B84 C082       436            push dpl
0B86 C0E0       436            push acc
0B88 90003E     436            mov dptr, #blank
0B8B 120241     436            lcall ?Send_Constant_String
0B8E D0E0       436            pop acc
0B90 D082       436            pop dpl
0B92 D083       436            pop dph
0B94            437   
0B94 7AFA       438            mov R2, #250
0B96 120A31     439            lcall waitms
0B99            440            
0B99            441   Forever:
0B99            442            ; Wait 50 ms between readings
0B99 7A32       443            mov R2, #50
0B9B 120A31     444            lcall waitms
0B9E            445   
0B9E            446            ; output? 
0B9E 300604     447            jnb seconds_flag, no_second
0BA1 C206       448            clr seconds_flag
0BA3 B295       449            cpl P1.5
0BA5            450   
0BA5            451   no_second:
0BA5            452   
0BA5 7A32       453            mov R2, #50
0BA7 120A31     454            lcall waitms
0BAA            455   
0BAA 020BAD     456            ljmp FSM_select
0BAD            457   
0BAD            458            ;Set_Cursor(2, 11)
0BAD            459            ;mov r0, #80
0BAD            460            ;mov x+0, r0
0BAD            461            ;mov x+1, #0 
0BAD            462            ;mov x+2, #0
0BAD            463            ;mov x+3, #0
0BAD            464            ;lcall hex2bcd
0BAD            465            ;lcall Display_formated_BCD
0BAD            466            
0BAD            467            ;check if reaches forever
0BAD            468            ;Set_Cursor(1, 1)
0BAD            469            ;Send_Constant_String(#forever_message)
0BAD            470            ;mov R2, #250
0BAD            471            ;lcall waitms
0BAD            472            ;ljmp FSM_select
0BAD            473   
0BAD            474   ;no_second:
0BAD            475   ;        ljmp Forever
0BAD            476   
0BAD            477   ;for testing since there's no other fsm right now
0BAD            478   
0BAD            479   
0BAD            480   ;begin select FSM
0BAD            481   FSM_select:
0BAD E53D       482            mov a, selecting_state
0BAF            483   
0BAF            484   select_wait:
0BAF B4004C     485            cjne a, #0, select_soak_time ;checks the state
0BB2 C0E0       486            push acc
0BB4 7401       486            mov a, #1
0BB6 14         486            dec a
0BB7 12024E     486            lcall ?Set_Cursor_1 ; Select column and row
0BBA D0E0       486            pop acc
0BBC C083       487            push dph
0BBE C082       487            push dpl
0BC0 C0E0       487            push acc
0BC2 90004F     487            mov dptr, #swait_message1
0BC5 120241     487            lcall ?Send_Constant_String
0BC8 D0E0       487            pop acc
0BCA D082       487            pop dpl
0BCC D083       487            pop dph
0BCE C0E0       488            push acc
0BD0 7401       488            mov a, #1
0BD2 14         488            dec a
0BD3 12024C     488            lcall ?Set_Cursor_2 ; Select column and row
0BD6 D0E0       488            pop acc
0BD8 C083       489            push dph
0BDA C082       489            push dpl
0BDC C0E0       489            push acc
0BDE 900060     489            mov dptr, #swait_message2
0BE1 120241     489            lcall ?Send_Constant_String
0BE4 D0E0       489            pop acc
0BE6 D082       489            pop dpl
0BE8 D083       489            pop dph
0BEA 7AFA       490            mov R2, #250
0BEC 120A31     491            lcall waitms
0BEF            492       ;lcall ADC_to_PB ;checks for button press
0BEF 120DF4     493       lcall rst_check
0BF2 120DFF     494       lcall nxt_check
0BF5 120EC2     495       lcall s_s_check
0BF8 020B99     496       ljmp forever ;i believe 
0BFB            497   
0BFB            498   select_soak_temp_ah:
0BFB 020C83     499            ljmp select_soak_temp
0BFE            500   
0BFE            501   select_soak_time:
0BFE B401FA     502            cjne a, #1, select_soak_temp_ah ;checks the state
0C01 C0E0       503            push acc
0C03 7401       503            mov a, #1
0C05 14         503            dec a
0C06 12024E     503            lcall ?Set_Cursor_1 ; Select column and row
0C09 D0E0       503            pop acc
0C0B C083       504            push dph
0C0D C082       504            push dpl
0C0F C0E0       504            push acc
0C11 900071     504            mov dptr, #sstime_message1
0C14 120241     504            lcall ?Send_Constant_String
0C17 D0E0       504            pop acc
0C19 D082       504            pop dpl
0C1B D083       504            pop dph
0C1D C0E0       505            push acc
0C1F 7401       505            mov a, #1
0C21 14         505            dec a
0C22 12024C     505            lcall ?Set_Cursor_2 ; Select column and row
0C25 D0E0       505            pop acc
0C27 C083       506            push dph
0C29 C082       506            push dpl
0C2B C0E0       506            push acc
0C2D 900082     506            mov dptr, #sstime_message2
0C30 120241     506            lcall ?Send_Constant_String
0C33 D0E0       506            pop acc
0C35 D082       506            pop dpl
0C37 D083       506            pop dph
0C39            507       ;Set_Cursor(2, 11)
0C39 C005       508       push AR5  ;display the current soak_time
0C3B AD30       509       mov R5, x
0C3D 853F30     510       mov x+0, soak_time
0C40 753100     511            mov x+1, #0
0C43 753200     512            mov x+2, #0
0C46 753300     513            mov x+3, #0
0C49 C0E0       514            push acc
0C4B 740B       514            mov a, #11
0C4D 14         514            dec a
0C4E 12024C     514            lcall ?Set_Cursor_2 ; Select column and row
0C51 D0E0       514            pop acc
0C53            515            ;Send_Constant_String(#its_works)
0C53 1202BC     516       lcall hex2bcd
0C56 120A37     517       lcall Display_formated_BCD
0C59 8D30       518       mov x, R5
0C5B D005       519       pop AR5
0C5D            520       ;lcall ADC_to_PB ;checks for button press
0C5D 120DF4     521       lcall rst_check
0C60 C003       522       push AR3 ;set the paramaters for up/down
0C62 C004       523       push AR4
0C64 C005       524       push AR5
0C66 7B3C       525       mov R3, #0x3C ;min value allowed for soak time !check it please
0C68 7C78       526       mov R4, #0x78 ;120  ;max value, !check it please, also is the dec? hex?
0C6A AD3F       527       mov R5, soak_time
0C6C 120E32     528       lcall up_check
0C6F 120E7A     529       lcall down_check
0C72 8D3F       530       mov soak_time, R5
0C74 D005       531       pop AR5
0C76 D004       532       pop AR4
0C78 D003       533       pop AR3  ;am i doing this right?
0C7A 120EC2     534       lcall s_s_check
0C7D 120DFF     535       lcall nxt_check
0C80 020B99     536       ljmp forever ;i believe 
0C83            537   
0C83            538   select_soak_temp:
0C83 B40279     539            cjne a, #2, select_reflow_time ;checks the state
0C86 C0E0       540            push acc
0C88 7401       540            mov a, #1
0C8A 14         540            dec a
0C8B 12024E     540            lcall ?Set_Cursor_1 ; Select column and row
0C8E D0E0       540            pop acc
0C90 C083       541            push dph
0C92 C082       541            push dpl
0C94 C0E0       541            push acc
0C96 900093     541            mov dptr, #sstemp_message1
0C99 120241     541            lcall ?Send_Constant_String
0C9C D0E0       541            pop acc
0C9E D082       541            pop dpl
0CA0 D083       541            pop dph
0CA2 C0E0       542            push acc
0CA4 7401       542            mov a, #1
0CA6 14         542            dec a
0CA7 12024C     542            lcall ?Set_Cursor_2 ; Select column and row
0CAA D0E0       542            pop acc
0CAC C083       543            push dph
0CAE C082       543            push dpl
0CB0 C0E0       543            push acc
0CB2 9000A4     543            mov dptr, #sstemp_message2
0CB5 120241     543            lcall ?Send_Constant_String
0CB8 D0E0       543            pop acc
0CBA D082       543            pop dpl
0CBC D083       543            pop dph
0CBE C0E0       544            push acc
0CC0 740B       544            mov a, #11
0CC2 14         544            dec a
0CC3 12024C     544            lcall ?Set_Cursor_2 ; Select column and row
0CC6 D0E0       544            pop acc
0CC8 C005       545       push AR5  ;display current soak temp
0CCA AD30       546       mov R5, x
0CCC 854130     547       mov x, soak_temp
0CCF 1202BC     548       lcall hex2bcd
0CD2 120A37     549       lcall Display_formated_BCD
0CD5 8D30       550       mov x, R5
0CD7 D005       551       pop AR5
0CD9            552       ;lcall ADC_to_PB ;checks for button press
0CD9 120DF4     553       lcall rst_check
0CDC C003       554       push AR3 ;set the paramaters for up/down
0CDE C004       555       push AR4
0CE0 C005       556       push AR5
0CE2 7B96       557       mov R3, #0x96 ;min value allowed !check it please (150 decimal)
0CE4 7CC8       558       mov R4, #0xC8 ;max value, !check it please, also is the dec? hex? (200 decimal)
0CE6 AD41       559       mov R5, soak_temp
0CE8 120E32     560       lcall up_check
0CEB 120E7A     561       lcall down_check
0CEE 8D41       562       mov soak_temp, R5
0CF0 D005       563       pop AR5
0CF2 D004       564       pop AR4
0CF4 D003       565       pop AR3  ;am i doing this right?
0CF6 120EC2     566       lcall s_s_check
0CF9 120DFF     567       lcall nxt_check
0CFC 020B99     568       ljmp forever ;i believe 
0CFF            569   
0CFF            570   select_reflow_time:
0CFF B40379     571            cjne a, #3, select_reflow_temp ;checks the state
0D02 C0E0       572            push acc
0D04 7401       572            mov a, #1
0D06 14         572            dec a
0D07 12024E     572            lcall ?Set_Cursor_1 ; Select column and row
0D0A D0E0       572            pop acc
0D0C C083       573            push dph
0D0E C082       573            push dpl
0D10 C0E0       573            push acc
0D12 9000B5     573            mov dptr, #srtime_message1
0D15 120241     573            lcall ?Send_Constant_String
0D18 D0E0       573            pop acc
0D1A D082       573            pop dpl
0D1C D083       573            pop dph
0D1E C0E0       574            push acc
0D20 7401       574            mov a, #1
0D22 14         574            dec a
0D23 12024C     574            lcall ?Set_Cursor_2 ; Select column and row
0D26 D0E0       574            pop acc
0D28 C083       575            push dph
0D2A C082       575            push dpl
0D2C C0E0       575            push acc
0D2E 9000C6     575            mov dptr, #srtime_message2
0D31 120241     575            lcall ?Send_Constant_String
0D34 D0E0       575            pop acc
0D36 D082       575            pop dpl
0D38 D083       575            pop dph
0D3A C0E0       576            push acc
0D3C 740B       576            mov a, #11
0D3E 14         576            dec a
0D3F 12024C     576            lcall ?Set_Cursor_2 ; Select column and row
0D42 D0E0       576            pop acc
0D44 C005       577       push AR5  ;display current reflow time
0D46 AD30       578       mov R5, x
0D48 854330     579       mov x, reflow_time
0D4B 1202BC     580       lcall hex2bcd
0D4E 120A37     581       lcall Display_formated_BCD
0D51 8D30       582       mov x, R5
0D53 D005       583       pop AR5
0D55            584       ;lcall ADC_to_PB ;checks for button press
0D55 120DF4     585       lcall rst_check
0D58 C003       586       push AR3 ;set the paramaters for up/down
0D5A C004       587       push AR4
0D5C C005       588       push AR5
0D5E 7B2D       589       mov R3, #0x2D ;45 min value allowed !check it please
0D60 7C4B       590       mov R4, #0x4B ;75 max value, !check it please, also is the dec? hex?
0D62 AD43       591       mov R5, reflow_time
0D64 120E32     592       lcall up_check
0D67 120E7A     593       lcall down_check
0D6A 8D43       594       mov reflow_time, R5
0D6C D005       595       pop AR5
0D6E D004       596       pop AR4
0D70 D003       597       pop AR3  ;am i doing this right?
0D72 120EC2     598       lcall s_s_check
0D75 120DFF     599       lcall nxt_check
0D78 020B99     600       ljmp forever ;i believe 
0D7B            601   
0D7B            602   select_reflow_temp:
0D7B            603            ;shouldn't need to check the state
0D7B C0E0       604            push acc
0D7D 7401       604            mov a, #1
0D7F 14         604            dec a
0D80 12024E     604            lcall ?Set_Cursor_1 ; Select column and row
0D83 D0E0       604            pop acc
0D85 C083       605            push dph
0D87 C082       605            push dpl
0D89 C0E0       605            push acc
0D8B 9000D7     605            mov dptr, #srtemp_message1
0D8E 120241     605            lcall ?Send_Constant_String
0D91 D0E0       605            pop acc
0D93 D082       605            pop dpl
0D95 D083       605            pop dph
0D97 C0E0       606            push acc
0D99 7401       606            mov a, #1
0D9B 14         606            dec a
0D9C 12024C     606            lcall ?Set_Cursor_2 ; Select column and row
0D9F D0E0       606            pop acc
0DA1 C083       607            push dph
0DA3 C082       607            push dpl
0DA5 C0E0       607            push acc
0DA7 9000E8     607            mov dptr, #srtemp_message2
0DAA 120241     607            lcall ?Send_Constant_String
0DAD D0E0       607            pop acc
0DAF D082       607            pop dpl
0DB1 D083       607            pop dph
0DB3 C0E0       608            push acc
0DB5 740B       608            mov a, #11
0DB7 14         608            dec a
0DB8 12024C     608            lcall ?Set_Cursor_2 ; Select column and row
0DBB D0E0       608            pop acc
0DBD C005       609       push AR5  ;display current reflow temp
0DBF AD30       610       mov R5, x
0DC1 854530     611       mov x, reflow_temp
0DC4 1202BC     612       lcall hex2bcd
0DC7 120A37     613       lcall Display_formated_BCD
0DCA 8D30       614       mov x, R5
0DCC D005       615       pop AR5
0DCE            616       ;lcall ADC_to_PB ;checks for button press
0DCE 120DF4     617       lcall rst_check
0DD1 C003       618       push AR3  ;set the paramaters for up/down
0DD3 C004       619       push AR4
0DD5 C005       620       push AR5
0DD7 7BD9       621       mov R3, #0xD9 ;217 DEC ;min value allowed !check it please
0DD9 7CFF       622       mov R4, #0xFF ; 255 DEC ;max value, !check it please, also is the dec? hex?
0DDB AD45       623       mov R5, reflow_temp
0DDD 120E32     624       lcall up_check
0DE0 120E7A     625       lcall down_check
0DE3 8D45       626       mov reflow_temp, R5
0DE5 D005       627       pop AR5
0DE7 D004       628       pop AR4
0DE9 D003       629       pop AR3  ;am i doing this right?
0DEB 120EC2     630       lcall s_s_check
0DEE 120DFF     631       lcall nxt_check
0DF1 020B99     632       ljmp forever ;i believe 
0DF4            633   
0DF4            634   ;maybe make these macros :(
0DF4            635   ;use R3 & R4 & R5 as parameters
0DF4            636   rst_check:
0DF4 120AEB     637            lcall ADC_to_PB
0DF7 A204       638            mov c, RST
0DF9 5001       639       jnc rst_check_0 ;!could be jc
0DFB 22         640       ret
0DFC            641   rst_check_0:
0DFC 020279     642       ljmp reset_state ;or whatever it's called, wait state of oven fsm
0DFF            643   
0DFF            644   nxt_check:
0DFF 120AEB     645            lcall ADC_to_PB
0E02 A203       646            mov c, NXT
0E04 5001       647       jnc next_check_1 
0E06 22         648            ret
0E07            649   next_check_1: 
0E07            650       ;load_x(selecting_state)
0E07            651       ;load_y(4)
0E07 853D30     652            mov x, selecting_state
0E0A 753100     653            mov x+1, #0
0E0D 753200     654            mov x+2, #0
0E10 753300     655            mov x+3, #0
0E13 753404     656            mov y, #0x04
0E16 753500     657            mov y+1, #0
0E19 753600     658            mov y+2, #0
0E1C 753700     659            mov y+3, #0
0E1F 1203FC     660       lcall x_eq_y
0E22 D3         661            setb c
0E23 200507     662            jb mf, next_check_2
0E26 E53D       663       mov a, selecting_state 
0E28 3400       664       addc a, #0 ;uh
0E2A F53D       665       mov selecting_state, a
0E2C 22         666       ret
0E2D            667   next_check_2:
0E2D C3         668            clr c
0E2E 753D00     669            mov selecting_state, #0 ;can't go above 4 (there are 5 states)
0E31            670   
0E31 22         671            ret
0E32            672   
0E32            673   up_check: ;R4 max
0E32 120AEB     674            lcall ADC_to_PB
0E35 A202       675            mov c, UP
0E37 5001       676            jnc up_check_1
0E39 22         677            ret 
0E3A            678   up_check_1:
0E3A 8C30       679            mov x, R4
0E3C 753100     680            mov x+1, #0
0E3F 753200     681            mov x+2, #0
0E42 753300     682            mov x+3, #0
0E45 8D34       683            mov y, R5
0E47 753500     684            mov y+1, #0
0E4A 753600     685            mov y+2, #0
0E4D 753700     686            mov y+3, #0
0E50 1203E0     687            lcall x_gt_y ;max > value
0E53 D3         688            setb c
0E54 300505     689            jnb mf, up_check_2
0E57 ED         690            mov a, R5
0E58 3400       691            addc a, #0 ;dec? hex?
0E5A FD         692            mov R5, a
0E5B 22         693            ret
0E5C            694   up_check_2:
0E5C C3         695            clr c
0E5D C0E0       696            push acc
0E5F 740B       696            mov a, #11
0E61 14         696            dec a
0E62 12024C     696            lcall ?Set_Cursor_2 ; Select column and row
0E65 D0E0       696            pop acc
0E67 C083       697            push dph
0E69 C082       697            push dpl
0E6B C0E0       697            push acc
0E6D 9000F9     697            mov dptr, #too_high_message
0E70 120241     697            lcall ?Send_Constant_String
0E73 D0E0       697            pop acc
0E75 D082       697            pop dpl
0E77 D083       697            pop dph
0E79 22         698            ret
0E7A            699   
0E7A            700   down_check: ;R3 min
0E7A 120AEB     701            lcall ADC_to_PB
0E7D A201       702            mov c, DOWN
0E7F 5001       703            jnc down_check_1
0E81 22         704            ret
0E82            705   down_check_1:
0E82 8B30       706            mov x, R3
0E84 753100     707            mov x+1, #0
0E87 753200     708            mov x+2, #0
0E8A 753300     709            mov x+3, #0
0E8D 8D34       710            mov y, R5
0E8F 753500     711            mov y+1, #0
0E92 753600     712            mov y+2, #0
0E95 753700     713            mov y+3, #0
0E98 1203C4     714            lcall x_lt_y ;min < value
0E9B D3         715            setb c
0E9C 300505     716            jnb mf, down_check_2
0E9F ED         717            mov a, R5
0EA0 9400       718            subb a, #0 ;dec? hex?
0EA2 FD         719            mov R5, a
0EA3 22         720            ret
0EA4            721   down_check_2:
0EA4 C3         722            clr c
0EA5 C0E0       723            push acc
0EA7 740B       723            mov a, #11
0EA9 14         723            dec a
0EAA 12024C     723            lcall ?Set_Cursor_2 ; Select column and row
0EAD D0E0       723            pop acc
0EAF C083       724            push dph
0EB1 C082       724            push dpl
0EB3 C0E0       724            push acc
0EB5 900103     724            mov dptr, #too_low_message
0EB8 120241     724            lcall ?Send_Constant_String
0EBB D0E0       724            pop acc
0EBD D082       724            pop dpl
0EBF D083       724            pop dph
0EC1 22         725            ret
0EC2            726   
0EC2            727   s_s_check:
0EC2 120AEB     728            lcall ADC_to_PB
0EC5 A200       729            mov c, S_S
0EC7 5001       730            jnc s_s_check_done ;!could be jb
0EC9 22         731            ret
0ECA            732   s_s_check_done:
0ECA 020763     733            ljmp state0 ;or whatever it's called, 1st state of oven FSM
0ECD            734   
0ECD            735   END
