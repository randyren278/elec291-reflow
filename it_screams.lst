0000              1   ;please work
0000              2   ; do not touch functional except for
0000              3   ; pwm and load_X i think 
0000              4   
0000              5   
0000              6   ;with 5 adc push buttons
0000              7   ;to think about:
0000              8            ;adding another state for when start is pressed so that in forever if it gets sent back to FSM_select
0000              9            ;it will know not to ask for input/go through it
0000             10            ;making the checks into macros
0000             11   
0000             12   ;button functions: rst, next, up, down, start/stop
0000             13   ;display which you're in 
0000             14   ;start-> in the selecting fsm
0000             15   ;stop-> after reset_state in the oven fsm
0000             16   
0000             17   ; 76E003 ADC_Pushbuttons.asm: Reads push buttons using the ADC, AIN0 in P1.7
0000             18   
                 20   $LIST
0000             22   
0000             23   ;  N76E003 pinout:
0000             24   ;                               -------
0000             25   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             26   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             27   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             28   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             29   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             30   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             31   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             32   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             33   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             34   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             35   ;                               -------
0000             36   ;
0000             37   
0000             38   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             39   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             40   TIMER1_RATE         EQU 100      ; 100Hz or 10ms
0000             41   TIMER1_RELOAD       EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 1 input divide to 16 in T2MOD
0000             42   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             43   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             44   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             45   
0000             46   ORG 0x0000
0000 020BF0      47            ljmp main
002B             48   ORG 0x002B
002B 020B17      49            ljmp Timer2_ISR
002E             50   
002E             51   ;                     1234567890123456    <- This helps determine the location of the counter
002E 20206865    52   title:            db '  here we go!  ', 0
     72652077
     6520676F
     21202000
003E 20202020    53   blank:            db '                ', 0
     20202020
     20202020
     20202020
     00
004F 53657420    54   swait_message1:   db 'Set your values ', 0   ;s->select fsm, wait->state
     796F7572
     2076616C
     75657320
     00
0060 50726573    55   swait_message2:   db 'Press next      ', 0
     73206E65
     78742020
     20202020
     00
0071 53656C65    56   sstime_message1:  db 'Select soak time', 0   ;s->soak
     63742073
     6F616B20
     74696D65
     00
0082 536F616B    57   sstime_message2:  db 'Soak time:      ', 0
     2074696D
     653A2020
     20202020
     00
0093 53656C65    58   sstemp_message1:  db 'Select soak temp', 0   ;s->soak
     63742073
     6F616B20
     74656D70
     00
00A4 536F616B    59   sstemp_message2:  db 'Soak temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00B5 53656C65    60   srtime_message1:  db 'Select refl time', 0   ;r->reflow
     63742072
     65666C20
     74696D65
     00
00C6 5265666C    61   srtime_message2:  db 'Refl time:      ', 0
     2074696D
     653A2020
     20202020
     00
00D7 53656C65    62   srtemp_message1:  db 'Select refl temp', 0   ;r->reflow
     63742072
     65666C20
     74656D70
     00
00E8 5265666C    63   srtemp_message2:  db 'Refl temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00F9 6D617821    64   too_high_message: db 'max!     ', 0
     20202020
     2000
0103 6D696E21    65   too_low_message:  db 'min!     ', 0
     20202020
     2000
010D 68656C6C    66   forever_message:  db 'hello please', 0
     6F20706C
     65617365
     00
011A 64696500    67   its_works:        db 'die',0
011E 646F6E65    68   done_message:      db 'done!',0
     2100
0124 73746F70    69   stop_message:      db 'stopped!',0
     70656421
     00
012D             70                                               ;1234567890123456
012D 4F76656E    71   oven_fsm_message_0: db 'Oven State 0!   ',0
     20537461
     74652030
     21202020
     00
013E 4F76656E    72   oven_fsm_message_1: db 'Oven State 1!   ',0
     20537461
     74652031
     21202020
     00
014F 4F76656E    73   oven_fsm_message_2: db 'Oven State 2!   ',0
     20537461
     74652032
     21202020
     00
0160 4F76656E    74   oven_fsm_message_3: db 'Oven State 3!   ',0
     20537461
     74652033
     21202020
     00
0171 4F76656E    75   oven_fsm_message_4: db 'Oven State 4!   ',0
     20537461
     74652034
     21202020
     00
0182 4F76656E    76   oven_fsm_message_5: db 'Oven State 5!   ',0
     20537461
     74652035
     21202020
     00
0193             77   ;                                                   1234567890123456
0193 53657474    78   reset_state_message:   db 'Settings Reset! ', 0 ;for testing
     696E6773
     20526573
     65742120
     00
01A4 73746174    79   state1_message:   db 'state1          ', 0 ;for testing
     65312020
     20202020
     20202020
     00
01B5             80   
01B5             81   cseg
01B5             82   ; These 'equ' must match the hardware wiring
01B5             83   LCD_RS equ P1.3
01B5             84   LCD_E  equ P1.4
01B5             85   LCD_D4 equ P0.0
01B5             86   LCD_D5 equ P0.1
01B5             87   LCD_D6 equ P0.2
01B5             88   LCD_D7 equ P0.3
01B5             89   SOUND_OUT equ P1.5
01B5             90   PWM_OUT    EQU P1.0 ; Logic 1=oven on
01B5             91   
                 94   ;                     1234567890123456    <- This helps determine the location of the counte$LIST
02BC             96   
0000             97   BSEG
0000             98   ; These eight bit variables store the value of the pushbuttons after calling 'ADC_to_PB' below
0000             99   ;PB0: dbit 1 
0000            100   ;PB1: dbit 1     pretty sure left-right is 7-0
0000            101   ;PB2: dbit 1
0000            102   S_S: dbit 1 ;PB3
0001            103   DOWN: dbit 1 ;PB4
0002            104   UP: dbit 1 ;PB5
0003            105   NXT: dbit 1 ;PB6
0004            106   RST: dbit 1 ;PB7
0005            107   mf: dbit 1
0006            108   seconds_flag: dbit 1
0007            109   s_flag: dbit 1 ; set to 1 every time a second has passed
0008            110   oven_flag: dbit 1
0009            111   
0009            112   ;TODO: check if one is enough
0030            113   DSEG at 30H
0030            114   x: ds 4
0034            115   y: ds 4
0038            116   BCD: ds 5
003D            117   selecting_state: ds 1
003E            118   oven_state: ds 1
003F            119   soak_time: ds 1
0040            120   soak_temp: ds 1
0041            121   reflow_time: ds 1
0042            122   reflow_temp: ds 2
0044            123   Count1ms:     ds 2 
0046            124   sec: ds 1
0047            125   temp: ds 1
0048            126   pwm_counter:  ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0049            127   pwm:          ds 1 ; pwm percentage
004A            128   seconds:      ds 1 ; a seconds counter attached to Timer 2 ISR
004B            129   
                574   $LIST
                133       $LIST
0A7F            135   
0A7F            136   CSEG
0A7F            137   Init_All:
0A7F            138            ; Configure all the pins for biderectional I/O
0A7F 75AC00     139            mov     P3M1, #0x00
0A82 75AD00     140            mov     P3M2, #0x00
0A85 75B300     141            mov     P1M1, #0x00
0A88 75B400     142            mov     P1M2, #0x00
0A8B 75B100     143            mov     P0M1, #0x00
0A8E 75B200     144            mov     P0M2, #0x00
0A91            145            
0A91 438E10     146            orl     CKCON, #0x10 ; CLK is the input for timer 1
0A94 438780     147            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0A97 759852     148            mov     SCON, #0x52
0A9A 53C4DF     149            anl     T3CON, #0b11011111
0A9D 53890F     150            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0AA0 438920     151            orl     TMOD, #0x20 ; Timer 1 Mode 2
0AA3            152            
0AA3            153            ; Using timer 0 for delay functions.  Initialize here:
0AA3 C28C       154            clr     TR0 ; Stop timer 0
0AA5 438E08     155            orl     CKCON,#0x08 ; CLK is the input for timer 0
0AA8 5389F0     156            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0AAB 438901     157            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0AAE            158            
0AAE            159            ; Initialize and start the ADC:
0AAE            160            
0AAE            161            ; AIN0 is connected to P1.7.  Configure P1.7 as input.
0AAE 43B380     162            orl     P1M1, #0b10000000
0AB1 53B47F     163            anl     P1M2, #0b01111111
0AB4            164            
0AB4            165            ; AINDIDS select if some pins are analog inputs or digital I/O:
0AB4 75F600     166            mov AINDIDS, #0x00 ; Disable all analog inputs
0AB7 43F601     167            orl AINDIDS, #0b00000001 ; Using AIN0
0ABA 43E101     168            orl ADCCON1, #0x01 ; Enable ADC
0ABD            169   
0ABD            170            ; timer 2 ?? 
0ABD 120AF5     171            lcall Timer2_Init
0AC0 D2AF       172            setb EA
0AC2            173   
0AC2            174            
0AC2 22         175            ret
0AC3            176            
0AC3            177   wait_1ms:
0AC3 C28C       178            clr     TR0 ; Stop timer 0
0AC5 C28D       179            clr     TF0 ; Clear overflow flag
0AC7 758CBF     180            mov     TH0, #high(TIMER0_RELOAD_1MS)
0ACA 758A28     181            mov     TL0,#low(TIMER0_RELOAD_1MS)
0ACD D28C       182            setb TR0
0ACF 308DFD     183            jnb     TF0, $ ; Wait for overflow
0AD2 22         184            ret
0AD3            185   
0AD3            186   ; Wait the number of miliseconds in R2
0AD3            187   waitms:
0AD3 120AC3     188            lcall wait_1ms
0AD6 DAFB       189            djnz R2, waitms
0AD8 22         190            ret
0AD9            191   
0AD9            192   ;set cursor before, also might have to change format     
0AD9            193   Display_formated_BCD:  
0AD9            194       ;Display_BCD(bcd+4) 
0AD9            195       ;Display_BCD(bcd+3) 
0AD9 C000       196            push ar0
0ADB A83A       196            mov r0, bcd+2
0ADD 120253     196            lcall ?Display_BCD
0AE0 D000       196            pop ar0 
0AE2 C000       197            push ar0
0AE4 A839       197            mov r0, bcd+1
0AE6 120253     197            lcall ?Display_BCD
0AE9 D000       197            pop ar0 
0AEB C000       198            push ar0
0AED A838       198            mov r0, bcd+0
0AEF 120253     198            lcall ?Display_BCD
0AF2 D000       198            pop ar0  
0AF4 22         199       ret
0AF5            200   
0AF5            201   Timer2_Init:
0AF5 75C800     202            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0AF8 75CDBF     203            mov TH2, #high(TIMER2_RELOAD)
0AFB 75CC28     204            mov TL2, #low(TIMER2_RELOAD)
0AFE            205            ; Set the reload value
0AFE 75C980     206            mov T2MOD, #1000_0000b 
0B01            207            ;orl T2MOD, #0x80 ; Enable timer 2 autoreload this was it before
0B01 75CBBF     208            mov RCMP2H, #high(TIMER2_RELOAD)
0B04 75CA28     209            mov RCMP2L, #low(TIMER2_RELOAD)
0B07            210            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0B07 E4         211            clr a
0B08 F544       212            mov Count1ms+0, a
0B0A F545       213            mov Count1ms+1, a
0B0C 754600     214            mov sec, #0
0B0F C206       215            clr seconds_flag
0B11            216            ; Enable the timer and interrupts
0B11 439B80     217            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0B14 D2CA       218       setb TR2  ; Enable timer 2
0B16 22         219            ret
0B17            220   ;---------------------------------;
0B17            221   ; ISR for timer 2                 ;
0B17            222   ;---------------------------------;
0B17            223   Timer2_ISR:
0B17 C2CF       224            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0B19            225            
0B19            226            ; The two registers used in the ISR must be saved in the stack
0B19 C0E0       227            push acc
0B1B C0D0       228            push psw
0B1D C034       229            push y+0
0B1F C035       230            push y+1
0B21 C036       231            push y+2
0B23 C037       232            push y+3
0B25 C030       233            push x+0
0B27 C031       234            push x+1
0B29 C032       235            push x+2
0B2B C033       236            push x+3
0B2D            237            
0B2D            238            ; Increment the 16-bit one mili second counter
0B2D 0544       239            inc Count1ms+0    ; Increment the low 8-bits first
0B2F E544       240            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0B31 7002       241            jnz Inc_Done_randys_version
0B33 0545       242            inc Count1ms+1
0B35            243   
0B35            244   Inc_Done_randys_version:
0B35            245   
0B35            246            ; CODE TO MAKE THE PWM WORK
0B35 C3         247            clr c
0B36 753049     248            mov x+0, #low (pwm % 0x10000) 
0B39 753100     248            mov x+1, #high(pwm % 0x10000) 
0B3C 753200     248            mov x+2, #low (pwm / 0x10000) 
0B3F 753300     248            mov x+3, #high(pwm / 0x10000) 
0B42 75340A     249            mov y+0, #low (10 % 0x10000) 
0B45 753500     249            mov y+1, #high(10 % 0x10000) 
0B48 753600     249            mov y+2, #low (10 / 0x10000) 
0B4B 753700     249            mov y+3, #high(10 / 0x10000) 
0B4E 120436     250            lcall mul32
0B51 C3         251            clr c
0B52 E530       252            mov a, x+0
0B54 9544       253            subb a, Count1ms+0
0B56 5005       254            jnc pwm_output
0B58 C3         255            clr c 
0B59 E531       256            mov a, x+1
0B5B 9545       257            subb a, Count1ms+1 ; If pwm_counter <= pwm then c=1
0B5D            258   pwm_output:
0B5D B3         259            cpl c
0B5E 9290       260            mov PWM_OUT, c
0B60            261   
0B60            262            ;check if 1000 ms has passed 
0B60 E544       263            mov a, Count1ms+0
0B62 B4E814     264            cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0B65 E545       265            mov a, Count1ms+1
0B67 B4030F     266            cjne a, #high(1000), Time_increment_done
0B6A            267   
0B6A            268            ; if1000 ms has passed 
0B6A            269   
0B6A E4         270            clr A
0B6B F544       271            mov Count1ms+0, A
0B6D F545       272            mov Count1ms+1, A
0B6F            273   
0B6F A208       274            mov c, oven_flag
0B71            275            ;addc seconds, #0 ; It is super easy to keep a seconds count here
0B71 E54A       276            mov  A, seconds   ; Load seconds into A
0B73 3400       277            addc A, #0       ; Add the carry to A
0B75 F54A       278            mov  seconds, A   ; Store the result back in seconds
0B77            279   
0B77 D206       280            setb seconds_flag
0B79            281   
0B79            282            ;increment second flag 
0B79            283   
0B79            284            ;mov a, seconds
0B79            285            ;add a, #1
0B79            286            ;da A
0B79            287            ;mov seconds, A
0B79            288   
0B79            289   
0B79            290   ;Inc_Done:
0B79            291            ; Check if second has passed
0B79            292   ;        mov a, Count1ms+0
0B79            293   ;        cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0B79            294   ;        mov a, Count1ms+1
0B79            295   ;        cjne a, #high(1000), Time_increment_done
0B79            296            
0B79            297            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0B79            298   ;        setb seconds_flag ; Let the main program know a second had passed
0B79            299            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0B79            300            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0B79            301   ;        clr a
0B79            302   ;        mov Count1ms+0, a
0B79            303   ;        mov Count1ms+1, a
0B79            304            ; Increment the time only when state flag is on
0B79            305            ;jnb state, Time_increment_done
0B79            306            
0B79            307   ;        mov a, sec
0B79            308   ;        add a, #0x01
0B79            309   ;        da a
0B79            310   ;        mov sec, a
0B79            311   ;        
0B79            312   ;        cjne a, #0x60, Time_increment_done
0B79            313   
0B79            314                    
0B79            315   Time_increment_done:
0B79 D033       316            pop x+3
0B7B D032       317            pop x+2
0B7D D031       318            pop x+1
0B7F D030       319            pop x+0
0B81 D037       320            pop y+3
0B83 D036       321            pop y+2
0B85 D035       322            pop y+1
0B87 D034       323            pop y+0
0B89 D0D0       324            pop psw
0B8B D0E0       325            pop acc
0B8D 32         326            reti
0B8E            327   
0B8E            328   
0B8E            329   
0B8E            330   
0B8E            331   
0B8E            332   
0B8E            333   
0B8E            334   ADC_to_PB:
0B8E C0E0       335            push acc
0B90 53E8F0     336            anl ADCCON0, #0xF0
0B93 43E800     337            orl ADCCON0, #0x00 ; Select AIN0
0B96            338            
0B96 C2EF       339            clr ADCF
0B98 D2EE       340            setb ADCS   ; ADC start trigger signal
0B9A 30EFFD     341       jnb ADCF, $ ; Wait for conversion complete
0B9D            342   
0B9D D204       343            setb RST;PB7
0B9F D203       344            setb NXT;PB6
0BA1 D202       345            setb UP;PB5
0BA3 D201       346            setb DOWN;PB4
0BA5 D200       347            setb S_S;PB3
0BA7            348            ;setb PB2
0BA7            349            ;setb PB1
0BA7            350            ;setb PB0
0BA7            351            
0BA7            352            ; Check PB7
0BA7            353   ;ADC_to_PB_L7:
0BA7            354   ;        clr c
0BA7            355   ;        mov a, ADCRH
0BA7            356   ;        subb a, #0xf0
0BA7            357   ;        jc ADC_to_PB_L6
0BA7            358   ;        clr RST;PB7
0BA7            359   ;        ret
0BA7            360   ;
0BA7            361   ;        ; Check PB6
0BA7            362   ;ADC_to_PB_L6:
0BA7            363   ;        clr c
0BA7            364   ;        mov a, ADCRH
0BA7            365   ;        subb a, #0xd0
0BA7            366   ;        jc ADC_to_PB_L5
0BA7            367   ;        clr NXT;PB6
0BA7            368   ;        ret
0BA7            369   
0BA7            370            ; Check PB5
0BA7            371   ADC_to_PB_L5:
0BA7 C3         372            clr c
0BA8 E5C3       373            mov a, ADCRH
0BAA 94B0       374            subb a, #0xb0
0BAC 4005       375            jc ADC_to_PB_L4
0BAE C204       376            clr RST;PB5
0BB0 D0E0       377            pop acc
0BB2 22         378            ret
0BB3            379   
0BB3            380            ; Check PB4
0BB3            381   ADC_to_PB_L4:
0BB3 C3         382            clr c
0BB4 E5C3       383            mov a, ADCRH
0BB6 9490       384            subb a, #0x90
0BB8 4005       385            jc ADC_to_PB_L3
0BBA C203       386            clr NXT;PB4
0BBC D0E0       387            pop acc
0BBE 22         388            ret
0BBF            389   
0BBF            390            ; Check PB3
0BBF            391   ADC_to_PB_L3:
0BBF C3         392            clr c
0BC0 E5C3       393            mov a, ADCRH
0BC2 9470       394            subb a, #0x70
0BC4 4005       395            jc ADC_to_PB_L2
0BC6 C202       396            clr UP;PB3
0BC8 D0E0       397            pop acc
0BCA 22         398            ret
0BCB            399   
0BCB            400            ; Check PB2
0BCB            401   ADC_to_PB_L2:
0BCB C3         402            clr c
0BCC E5C3       403            mov a, ADCRH
0BCE 9450       404            subb a, #0x50
0BD0 4005       405            jc ADC_to_PB_L1
0BD2 C201       406            clr DOWN
0BD4 D0E0       407            pop acc
0BD6 22         408            ret
0BD7            409   
0BD7            410            ; Check PB1
0BD7            411   ADC_to_PB_L1:
0BD7 C3         412            clr c
0BD8 E5C3       413            mov a, ADCRH
0BDA 9430       414            subb a, #0x30
0BDC 4005       415            jc ADC_to_PB_L0
0BDE C200       416            clr S_S
0BE0 D0E0       417            pop acc
0BE2 22         418            ret
0BE3            419   
0BE3            420            ; Check PB0
0BE3            421   ADC_to_PB_L0:
0BE3 C3         422            clr c
0BE4 E5C3       423            mov a, ADCRH
0BE6 9410       424            subb a, #0x10
0BE8 4003       425            jc ADC_to_PB_Done
0BEA            426            ;clr PB0
0BEA D0E0       427            pop acc
0BEC 22         428            ret
0BED            429            
0BED            430   ADC_to_PB_Done:
0BED            431            ; No pusbutton pressed  
0BED D0E0       432            pop acc
0BEF 22         433            ret
0BF0            434            
0BF0            435   main:
0BF0 75817F     436            mov sp, #0x7f
0BF3 12052C     437            lcall Temp_Init_All
0BF6 120A7F     438            lcall Init_All
0BF9 12020E     439       lcall LCD_4BIT
0BFC            440       
0BFC 120269     441       lcall state_init ;From State_Machine.inc
0BFF            442       
0BFF            443       ; initial messages in LCD
0BFF C0E0       444            push acc
0C01 7401       444            mov a, #1
0C03 14         444            dec a
0C04 12024E     444            lcall ?Set_Cursor_1 ; Select column and row
0C07 D0E0       444            pop acc
0C09 C083       445            push dph
0C0B C082       445            push dpl
0C0D C0E0       445            push acc
0C0F 90002E     445            mov dptr, #Title
0C12 120241     445            lcall ?Send_Constant_String
0C15 D0E0       445            pop acc
0C17 D082       445            pop dpl
0C19 D083       445            pop dph
0C1B C0E0       446            push acc
0C1D 7401       446            mov a, #1
0C1F 14         446            dec a
0C20 12024C     446            lcall ?Set_Cursor_2 ; Select column and row
0C23 D0E0       446            pop acc
0C25 C083       447            push dph
0C27 C082       447            push dpl
0C29 C0E0       447            push acc
0C2B 90003E     447            mov dptr, #blank
0C2E 120241     447            lcall ?Send_Constant_String
0C31 D0E0       447            pop acc
0C33 D082       447            pop dpl
0C35 D083       447            pop dph
0C37            448   
0C37 7AFA       449            mov R2, #250
0C39 120AD3     450            lcall waitms
0C3C            451            
0C3C            452   Forever:
0C3C            453            ; Wait 50 ms between readings
0C3C 7A32       454            mov R2, #50
0C3E 120AD3     455            lcall waitms
0C41            456   
0C41            457            ; output? 
0C41 300604     458            jnb seconds_flag, no_second
0C44 C206       459            clr seconds_flag
0C46 B295       460            cpl P1.5
0C48            461   
0C48            462   no_second:
0C48            463   
0C48 7A32       464            mov R2, #50
0C4A 120AD3     465            lcall waitms
0C4D            466   
0C4D 020C50     467            ljmp FSM_select
0C50            468   
0C50            469            ;Set_Cursor(2, 11)
0C50            470            ;mov r0, #80
0C50            471            ;mov x+0, r0
0C50            472            ;mov x+1, #0 
0C50            473            ;mov x+2, #0
0C50            474            ;mov x+3, #0
0C50            475            ;lcall hex2bcd
0C50            476            ;lcall Display_formated_BCD
0C50            477            
0C50            478            ;check if reaches forever
0C50            479            ;Set_Cursor(1, 1)
0C50            480            ;Send_Constant_String(#forever_message)
0C50            481            ;mov R2, #250
0C50            482            ;lcall waitms
0C50            483            ;ljmp FSM_select
0C50            484   
0C50            485   ;no_second:
0C50            486   ;        ljmp Forever
0C50            487   
0C50            488   ;for testing since there's no other fsm right now
0C50            489   
0C50            490   
0C50            491   ;begin select FSM
0C50            492   FSM_select:
0C50 E53D       493            mov a, selecting_state
0C52            494   
0C52            495   select_wait:
0C52 B4004C     496            cjne a, #0, select_soak_time ;checks the state
0C55 C0E0       497            push acc
0C57 7401       497            mov a, #1
0C59 14         497            dec a
0C5A 12024E     497            lcall ?Set_Cursor_1 ; Select column and row
0C5D D0E0       497            pop acc
0C5F C083       498            push dph
0C61 C082       498            push dpl
0C63 C0E0       498            push acc
0C65 90004F     498            mov dptr, #swait_message1
0C68 120241     498            lcall ?Send_Constant_String
0C6B D0E0       498            pop acc
0C6D D082       498            pop dpl
0C6F D083       498            pop dph
0C71 C0E0       499            push acc
0C73 7401       499            mov a, #1
0C75 14         499            dec a
0C76 12024C     499            lcall ?Set_Cursor_2 ; Select column and row
0C79 D0E0       499            pop acc
0C7B C083       500            push dph
0C7D C082       500            push dpl
0C7F C0E0       500            push acc
0C81 900060     500            mov dptr, #swait_message2
0C84 120241     500            lcall ?Send_Constant_String
0C87 D0E0       500            pop acc
0C89 D082       500            pop dpl
0C8B D083       500            pop dph
0C8D 7AFA       501            mov R2, #250
0C8F 120AD3     502            lcall waitms
0C92            503       ;lcall ADC_to_PB ;checks for button press
0C92 120EB0     504       lcall rst_check
0C95 120EBB     505       lcall nxt_check
0C98 120F7E     506       lcall s_s_check
0C9B 020C3C     507       ljmp forever ;i believe 
0C9E            508   
0C9E            509   select_soak_temp_ah:
0C9E 020D26     510            ljmp select_soak_temp
0CA1            511   
0CA1            512   select_soak_time:
0CA1 B401FA     513            cjne a, #1, select_soak_temp_ah ;checks the state
0CA4 C0E0       514            push acc
0CA6 7401       514            mov a, #1
0CA8 14         514            dec a
0CA9 12024E     514            lcall ?Set_Cursor_1 ; Select column and row
0CAC D0E0       514            pop acc
0CAE C083       515            push dph
0CB0 C082       515            push dpl
0CB2 C0E0       515            push acc
0CB4 900071     515            mov dptr, #sstime_message1
0CB7 120241     515            lcall ?Send_Constant_String
0CBA D0E0       515            pop acc
0CBC D082       515            pop dpl
0CBE D083       515            pop dph
0CC0 C0E0       516            push acc
0CC2 7401       516            mov a, #1
0CC4 14         516            dec a
0CC5 12024C     516            lcall ?Set_Cursor_2 ; Select column and row
0CC8 D0E0       516            pop acc
0CCA C083       517            push dph
0CCC C082       517            push dpl
0CCE C0E0       517            push acc
0CD0 900082     517            mov dptr, #sstime_message2
0CD3 120241     517            lcall ?Send_Constant_String
0CD6 D0E0       517            pop acc
0CD8 D082       517            pop dpl
0CDA D083       517            pop dph
0CDC            518       ;Set_Cursor(2, 11)
0CDC C005       519       push AR5  ;display the current soak_time
0CDE AD30       520       mov R5, x
0CE0 853F30     521       mov x+0, soak_time
0CE3 753100     522            mov x+1, #0
0CE6 753200     523            mov x+2, #0
0CE9 753300     524            mov x+3, #0
0CEC C0E0       525            push acc
0CEE 740B       525            mov a, #11
0CF0 14         525            dec a
0CF1 12024C     525            lcall ?Set_Cursor_2 ; Select column and row
0CF4 D0E0       525            pop acc
0CF6            526            ;Send_Constant_String(#its_works)
0CF6 1202BC     527       lcall hex2bcd
0CF9 120AD9     528       lcall Display_formated_BCD
0CFC 8D30       529       mov x, R5
0CFE D005       530       pop AR5
0D00            531       ;lcall ADC_to_PB ;checks for button press
0D00 120EB0     532       lcall rst_check
0D03 C003       533       push AR3 ;set the paramaters for up/down
0D05 C004       534       push AR4
0D07 C005       535       push AR5
0D09 7B3C       536       mov R3, #0x3C ;min value allowed for soak time !check it please
0D0B 7C78       537       mov R4, #0x78 ;120  ;max value, !check it please, also is the dec? hex?
0D0D AD3F       538       mov R5, soak_time
0D0F 120EEE     539       lcall up_check
0D12 120F36     540       lcall down_check
0D15 8D3F       541       mov soak_time, R5
0D17 D005       542       pop AR5
0D19 D004       543       pop AR4
0D1B D003       544       pop AR3  ;am i doing this right?
0D1D 120F7E     545       lcall s_s_check
0D20 120EBB     546       lcall nxt_check
0D23 020C3C     547       ljmp forever ;i believe 
0D26            548   
0D26            549   select_soak_temp:
0D26 B40203     550            cjne a, #2, $+6 ;checks the state
0D29 020D2F     551            ljmp $+6
0D2C 020DBB     552            ljmp select_reflow_time
0D2F C0E0       553            push acc
0D31 7401       553            mov a, #1
0D33 14         553            dec a
0D34 12024E     553            lcall ?Set_Cursor_1 ; Select column and row
0D37 D0E0       553            pop acc
0D39 C083       554            push dph
0D3B C082       554            push dpl
0D3D C0E0       554            push acc
0D3F 900093     554            mov dptr, #sstemp_message1
0D42 120241     554            lcall ?Send_Constant_String
0D45 D0E0       554            pop acc
0D47 D082       554            pop dpl
0D49 D083       554            pop dph
0D4B C0E0       555            push acc
0D4D 7401       555            mov a, #1
0D4F 14         555            dec a
0D50 12024C     555            lcall ?Set_Cursor_2 ; Select column and row
0D53 D0E0       555            pop acc
0D55 C083       556            push dph
0D57 C082       556            push dpl
0D59 C0E0       556            push acc
0D5B 9000A4     556            mov dptr, #sstemp_message2
0D5E 120241     556            lcall ?Send_Constant_String
0D61 D0E0       556            pop acc
0D63 D082       556            pop dpl
0D65 D083       556            pop dph
0D67 C0E0       557            push acc
0D69 740B       557            mov a, #11
0D6B 14         557            dec a
0D6C 12024C     557            lcall ?Set_Cursor_2 ; Select column and row
0D6F D0E0       557            pop acc
0D71 C005       558       push AR5  ;display current soak temp
0D73 C030       559            push x+0
0D75 C031       559            push x+1
0D77 C032       559            push x+2
0D79 C033       559            push x+3
0D7B 854030     560            mov x+0, soak_temp+0
0D7E 854131     561            mov x+1, soak_temp+1
0D81 753200     562            mov x+2, #0
0D84 753300     563            mov x+3, #0
0D87 1202BC     564       lcall hex2bcd
0D8A 120AD9     565       lcall Display_formated_BCD
0D8D            566       ;mov x, R5
0D8D D030       567            pop x+0
0D8F D031       567            pop x+1
0D91 D032       567            pop x+2
0D93 D033       567            pop x+3
0D95            568       ;lcall ADC_to_PB ;checks for button press
0D95 120EB0     569       lcall rst_check
0D98 C003       570       push AR3 ;set the paramaters for up/down
0D9A C004       571       push AR4
0D9C C005       572       push AR5
0D9E 7B96       573       mov R3, #0x96 ;min value allowed !check it please (150 decimal)
0DA0 7CC8       574       mov R4, #0xC8 ;max value, !check it please, also is the dec? hex? (200 decimal)
0DA2 AD40       575       mov R5, soak_temp
0DA4 120EEE     576       lcall up_check
0DA7 120F36     577       lcall down_check
0DAA 8D40       578       mov soak_temp, R5
0DAC D005       579       pop AR5
0DAE D004       580       pop AR4
0DB0 D003       581       pop AR3  ;am i doing this right?
0DB2 120F7E     582       lcall s_s_check
0DB5 120EBB     583       lcall nxt_check
0DB8 020C3C     584       ljmp forever ;i believe 
0DBB            585   
0DBB            586   select_reflow_time:
0DBB B40379     587            cjne a, #3, select_reflow_temp ;checks the state
0DBE C0E0       588            push acc
0DC0 7401       588            mov a, #1
0DC2 14         588            dec a
0DC3 12024E     588            lcall ?Set_Cursor_1 ; Select column and row
0DC6 D0E0       588            pop acc
0DC8 C083       589            push dph
0DCA C082       589            push dpl
0DCC C0E0       589            push acc
0DCE 9000B5     589            mov dptr, #srtime_message1
0DD1 120241     589            lcall ?Send_Constant_String
0DD4 D0E0       589            pop acc
0DD6 D082       589            pop dpl
0DD8 D083       589            pop dph
0DDA C0E0       590            push acc
0DDC 7401       590            mov a, #1
0DDE 14         590            dec a
0DDF 12024C     590            lcall ?Set_Cursor_2 ; Select column and row
0DE2 D0E0       590            pop acc
0DE4 C083       591            push dph
0DE6 C082       591            push dpl
0DE8 C0E0       591            push acc
0DEA 9000C6     591            mov dptr, #srtime_message2
0DED 120241     591            lcall ?Send_Constant_String
0DF0 D0E0       591            pop acc
0DF2 D082       591            pop dpl
0DF4 D083       591            pop dph
0DF6 C0E0       592            push acc
0DF8 740B       592            mov a, #11
0DFA 14         592            dec a
0DFB 12024C     592            lcall ?Set_Cursor_2 ; Select column and row
0DFE D0E0       592            pop acc
0E00 C005       593       push AR5  ;display current reflow time
0E02 AD30       594       mov R5, x
0E04 854130     595       mov x, reflow_time
0E07 1202BC     596       lcall hex2bcd
0E0A 120AD9     597       lcall Display_formated_BCD
0E0D 8D30       598       mov x, R5
0E0F D005       599       pop AR5
0E11            600       ;lcall ADC_to_PB ;checks for button press
0E11 120EB0     601       lcall rst_check
0E14 C003       602       push AR3 ;set the paramaters for up/down
0E16 C004       603       push AR4
0E18 C005       604       push AR5
0E1A 7B2D       605       mov R3, #0x2D ;45 min value allowed !check it please
0E1C 7C4B       606       mov R4, #0x4B ;75 max value, !check it please, also is the dec? hex?
0E1E AD41       607       mov R5, reflow_time
0E20 120EEE     608       lcall up_check
0E23 120F36     609       lcall down_check
0E26 8D41       610       mov reflow_time, R5
0E28 D005       611       pop AR5
0E2A D004       612       pop AR4
0E2C D003       613       pop AR3  ;am i doing this right?
0E2E 120F7E     614       lcall s_s_check
0E31 120EBB     615       lcall nxt_check
0E34 020C3C     616       ljmp forever ;i believe 
0E37            617   
0E37            618   select_reflow_temp:
0E37            619            ;shouldn't need to check the state
0E37 C0E0       620            push acc
0E39 7401       620            mov a, #1
0E3B 14         620            dec a
0E3C 12024E     620            lcall ?Set_Cursor_1 ; Select column and row
0E3F D0E0       620            pop acc
0E41 C083       621            push dph
0E43 C082       621            push dpl
0E45 C0E0       621            push acc
0E47 9000D7     621            mov dptr, #srtemp_message1
0E4A 120241     621            lcall ?Send_Constant_String
0E4D D0E0       621            pop acc
0E4F D082       621            pop dpl
0E51 D083       621            pop dph
0E53 C0E0       622            push acc
0E55 7401       622            mov a, #1
0E57 14         622            dec a
0E58 12024C     622            lcall ?Set_Cursor_2 ; Select column and row
0E5B D0E0       622            pop acc
0E5D C083       623            push dph
0E5F C082       623            push dpl
0E61 C0E0       623            push acc
0E63 9000E8     623            mov dptr, #srtemp_message2
0E66 120241     623            lcall ?Send_Constant_String
0E69 D0E0       623            pop acc
0E6B D082       623            pop dpl
0E6D D083       623            pop dph
0E6F C0E0       624            push acc
0E71 740B       624            mov a, #11
0E73 14         624            dec a
0E74 12024C     624            lcall ?Set_Cursor_2 ; Select column and row
0E77 D0E0       624            pop acc
0E79 C005       625       push AR5  ;display current reflow temp
0E7B AD30       626       mov R5, x
0E7D 854230     627       mov x, reflow_temp
0E80 1202BC     628       lcall hex2bcd
0E83 120AD9     629       lcall Display_formated_BCD
0E86 8D30       630       mov x, R5
0E88 D005       631       pop AR5
0E8A            632       ;lcall ADC_to_PB ;checks for button press
0E8A 120EB0     633       lcall rst_check
0E8D C003       634       push AR3  ;set the paramaters for up/down
0E8F C004       635       push AR4
0E91 C005       636       push AR5
0E93 7BD9       637       mov R3, #0xD9 ;217 DEC ;min value allowed !check it please
0E95 7CFF       638       mov R4, #0xFF ; 255 DEC ;max value, !check it please, also is the dec? hex?
0E97 AD42       639       mov R5, reflow_temp
0E99 120EEE     640       lcall up_check
0E9C 120F36     641       lcall down_check
0E9F 8D42       642       mov reflow_temp, R5
0EA1 D005       643       pop AR5
0EA3 D004       644       pop AR4
0EA5 D003       645       pop AR3  ;am i doing this right?
0EA7 120F7E     646       lcall s_s_check
0EAA 120EBB     647       lcall nxt_check
0EAD 020C3C     648       ljmp forever ;i believe 
0EB0            649   
0EB0            650   ;maybe make these macros :(
0EB0            651   ;use R3 & R4 & R5 as parameters
0EB0            652   rst_check:
0EB0 120B8E     653            lcall ADC_to_PB
0EB3 A204       654            mov c, RST
0EB5 5001       655       jnc rst_check_0 ;!could be jc
0EB7 22         656       ret
0EB8            657   rst_check_0:
0EB8 020279     658       ljmp reset_state ;or whatever it's called, wait state of oven fsm
0EBB            659   
0EBB            660   nxt_check:
0EBB 120B8E     661            lcall ADC_to_PB
0EBE A203       662            mov c, NXT
0EC0 5001       663       jnc next_check_1 
0EC2 22         664            ret
0EC3            665   next_check_1: 
0EC3            666       ;load_x(selecting_state)
0EC3            667       ;load_y(4)
0EC3 853D30     668            mov x, selecting_state
0EC6 753100     669            mov x+1, #0
0EC9 753200     670            mov x+2, #0
0ECC 753300     671            mov x+3, #0
0ECF 753404     672            mov y, #0x04
0ED2 753500     673            mov y+1, #0
0ED5 753600     674            mov y+2, #0
0ED8 753700     675            mov y+3, #0
0EDB 1203FC     676       lcall x_eq_y
0EDE D3         677            setb c
0EDF 200507     678            jb mf, next_check_2
0EE2 E53D       679       mov a, selecting_state 
0EE4 3400       680       addc a, #0 ;uh
0EE6 F53D       681       mov selecting_state, a
0EE8 22         682       ret
0EE9            683   next_check_2:
0EE9 C3         684            clr c
0EEA 753D00     685            mov selecting_state, #0 ;can't go above 4 (there are 5 states)
0EED            686   
0EED 22         687            ret
0EEE            688   
0EEE            689   up_check: ;R4 max
0EEE 120B8E     690            lcall ADC_to_PB
0EF1 A202       691            mov c, UP
0EF3 5001       692            jnc up_check_1
0EF5 22         693            ret 
0EF6            694   up_check_1:
0EF6 8C30       695            mov x, R4
0EF8 753100     696            mov x+1, #0
0EFB 753200     697            mov x+2, #0
0EFE 753300     698            mov x+3, #0
0F01 8D34       699            mov y, R5
0F03 753500     700            mov y+1, #0
0F06 753600     701            mov y+2, #0
0F09 753700     702            mov y+3, #0
0F0C 1203E0     703            lcall x_gt_y ;max > value
0F0F D3         704            setb c
0F10 300505     705            jnb mf, up_check_2
0F13 ED         706            mov a, R5
0F14 3400       707            addc a, #0 ;dec? hex?
0F16 FD         708            mov R5, a
0F17 22         709            ret
0F18            710   up_check_2:
0F18 C3         711            clr c
0F19 C0E0       712            push acc
0F1B 740B       712            mov a, #11
0F1D 14         712            dec a
0F1E 12024C     712            lcall ?Set_Cursor_2 ; Select column and row
0F21 D0E0       712            pop acc
0F23 C083       713            push dph
0F25 C082       713            push dpl
0F27 C0E0       713            push acc
0F29 9000F9     713            mov dptr, #too_high_message
0F2C 120241     713            lcall ?Send_Constant_String
0F2F D0E0       713            pop acc
0F31 D082       713            pop dpl
0F33 D083       713            pop dph
0F35 22         714            ret
0F36            715   
0F36            716   down_check: ;R3 min
0F36 120B8E     717            lcall ADC_to_PB
0F39 A201       718            mov c, DOWN
0F3B 5001       719            jnc down_check_1
0F3D 22         720            ret
0F3E            721   down_check_1:
0F3E 8B30       722            mov x, R3
0F40 753100     723            mov x+1, #0
0F43 753200     724            mov x+2, #0
0F46 753300     725            mov x+3, #0
0F49 8D34       726            mov y, R5
0F4B 753500     727            mov y+1, #0
0F4E 753600     728            mov y+2, #0
0F51 753700     729            mov y+3, #0
0F54 1203C4     730            lcall x_lt_y ;min < value
0F57 D3         731            setb c
0F58 300505     732            jnb mf, down_check_2
0F5B ED         733            mov a, R5
0F5C 9400       734            subb a, #0 ;dec? hex?
0F5E FD         735            mov R5, a
0F5F 22         736            ret
0F60            737   down_check_2:
0F60 C3         738            clr c
0F61 C0E0       739            push acc
0F63 740B       739            mov a, #11
0F65 14         739            dec a
0F66 12024C     739            lcall ?Set_Cursor_2 ; Select column and row
0F69 D0E0       739            pop acc
0F6B C083       740            push dph
0F6D C082       740            push dpl
0F6F C0E0       740            push acc
0F71 900103     740            mov dptr, #too_low_message
0F74 120241     740            lcall ?Send_Constant_String
0F77 D0E0       740            pop acc
0F79 D082       740            pop dpl
0F7B D083       740            pop dph
0F7D 22         741            ret
0F7E            742   
0F7E            743   s_s_check:
0F7E 120B8E     744            lcall ADC_to_PB
0F81 A200       745            mov c, S_S
0F83 5001       746            jnc s_s_check_done ;!could be jb
0F85 22         747            ret
0F86            748   s_s_check_done:
0F86 020761     749            ljmp FSM_Init ;or whatever it's called, 1st state of oven FSM
0F89            750   
0F89            751   END
