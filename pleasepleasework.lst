0000              1   ;please work
0000              2   ; do not touch functional except for
0000              3   ; pwm and load_X i think 
0000              4   
0000              5   
0000              6   ;with 5 adc push buttons
0000              7   ;to think about:
0000              8            ;adding another state for when start is pressed so that in forever if it gets sent back to FSM_select
0000              9            ;it will know not to ask for input/go through it
0000             10            ;making the checks into macros
0000             11   
0000             12   ;button functions: rst, next, up, down, start/stop
0000             13   ;display which you're in 
0000             14   ;start-> in the selecting fsm
0000             15   ;stop-> after reset_state in the oven fsm
0000             16   
0000             17   ; 76E003 ADC_Pushbuttons.asm: Reads push buttons using the ADC, AIN0 in P1.7
0000             18   
                 20   $LIST
0000             22   
0000             23   ;  N76E003 pinout:
0000             24   ;                               -------
0000             25   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             26   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             27   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             28   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             29   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             30   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             31   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             32   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             33   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             34   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             35   ;                               -------
0000             36   ;
0000             37   
0000             38   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             39   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             40   TIMER1_RATE         EQU 100      ; 100Hz or 10ms
0000             41   TIMER1_RELOAD       EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 1 input divide to 16 in T2MOD
0000             42   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             43   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             44   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             45   
0000             46   ORG 0x0000
0000 020BEB      47            ljmp main
002B             48   ORG 0x002B
002B 020B17      49            ljmp Timer2_ISR
002E             50   
002E             51   ;                     1234567890123456    <- This helps determine the location of the counter
002E 20206865    52   title:            db '  here we go!  ', 0
     72652077
     6520676F
     21202000
003E 20202020    53   blank:            db '                ', 0
     20202020
     20202020
     20202020
     00
004F 53657420    54   swait_message1:   db 'Set your values ', 0   ;s->select fsm, wait->state
     796F7572
     2076616C
     75657320
     00
0060 50726573    55   swait_message2:   db 'Press next      ', 0
     73206E65
     78742020
     20202020
     00
0071 53656C65    56   sstime_message1:  db 'Select soak time', 0   ;s->soak
     63742073
     6F616B20
     74696D65
     00
0082 536F616B    57   sstime_message2:  db 'Soak time:      ', 0
     2074696D
     653A2020
     20202020
     00
0093 53656C65    58   sstemp_message1:  db 'Select soak temp', 0   ;s->soak
     63742073
     6F616B20
     74656D70
     00
00A4 536F616B    59   sstemp_message2:  db 'Soak temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00B5 53656C65    60   srtime_message1:  db 'Select refl time', 0   ;r->reflow
     63742072
     65666C20
     74696D65
     00
00C6 5265666C    61   srtime_message2:  db 'Refl time:      ', 0
     2074696D
     653A2020
     20202020
     00
00D7 53656C65    62   srtemp_message1:  db 'Select refl temp', 0   ;r->reflow
     63742072
     65666C20
     74656D70
     00
00E8 5265666C    63   srtemp_message2:  db 'Refl temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00F9 6D617821    64   too_high_message: db 'max!     ', 0
     20202020
     2000
0103 6D696E21    65   too_low_message:  db 'min!     ', 0
     20202020
     2000
010D 68656C6C    66   forever_message:  db 'hello please', 0
     6F20706C
     65617365
     00
011A 64696500    67   its_works:        db 'die',0
011E 646F6E65    68   done_message:      db 'done!',0
     2100
0124 73746F70    69   stop_message:      db 'stopped!',0
     70656421
     00
012D             70                                               ;1234567890123456
012D 4F76656E    71   oven_fsm_message_0: db 'Oven State 0!   ',0
     20537461
     74652030
     21202020
     00
013E 4F76656E    72   oven_fsm_message_1: db 'Oven State 1!   ',0
     20537461
     74652031
     21202020
     00
014F 4F76656E    73   oven_fsm_message_2: db 'Oven State 2!   ',0
     20537461
     74652032
     21202020
     00
0160 4F76656E    74   oven_fsm_message_3: db 'Oven State 3!   ',0
     20537461
     74652033
     21202020
     00
0171 4F76656E    75   oven_fsm_message_4: db 'Oven State 4!   ',0
     20537461
     74652034
     21202020
     00
0182 4F76656E    76   oven_fsm_message_5: db 'Oven State 5!   ',0
     20537461
     74652035
     21202020
     00
0193             77   ;                                                   1234567890123456
0193 53657474    78   reset_state_message:   db 'Settings Reset! ', 0 ;for testing
     696E6773
     20526573
     65742120
     00
01A4 73746174    79   state1_message:   db 'state1          ', 0 ;for testing
     65312020
     20202020
     20202020
     00
01B5             80   
01B5             81   cseg
01B5             82   ; These 'equ' must match the hardware wiring
01B5             83   LCD_RS equ P1.3
01B5             84   LCD_E  equ P1.4
01B5             85   LCD_D4 equ P0.0
01B5             86   LCD_D5 equ P0.1
01B5             87   LCD_D6 equ P0.2
01B5             88   LCD_D7 equ P0.3
01B5             89   SOUND_OUT equ P1.5
01B5             90   PWM_OUT    EQU P1.0 ; Logic 1=oven on
01B5             91   
                 94   ;                     1234567890123456    <- This helps determine the location of the counte$LIST
02BC             96   
0000             97   BSEG
0000             98   ; These eight bit variables store the value of the pushbuttons after calling 'ADC_to_PB' below
0000             99   ;PB0: dbit 1 
0000            100   ;PB1: dbit 1     pretty sure left-right is 7-0
0000            101   ;PB2: dbit 1
0000            102   S_S: dbit 1 ;PB3
0001            103   DOWN: dbit 1 ;PB4
0002            104   UP: dbit 1 ;PB5
0003            105   NXT: dbit 1 ;PB6
0004            106   RST: dbit 1 ;PB7
0005            107   mf: dbit 1
0006            108   seconds_flag: dbit 1
0007            109   s_flag: dbit 1 ; set to 1 every time a second has passed
0008            110   oven_flag: dbit 1
0009            111   
0009            112   ;TODO: check if one is enough
0030            113   DSEG at 30H
0030            114   x: ds 4
0034            115   y: ds 4
0038            116   BCD: ds 5
003D            117   selecting_state: ds 1
003E            118   oven_state: ds 1
003F            119   soak_time: ds 1
0040            120   soak_temp: ds 1
0041            121   reflow_time: ds 1
0042            122   reflow_temp: ds 2
0044            123   Count1ms:     ds 2 
0046            124   sec: ds 1
0047            125   temp: ds 1
0048            126   pwm_counter:  ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0049            127   pwm:          ds 1 ; pwm percentage
004A            128   seconds:      ds 1 ; a seconds counter attached to Timer 2 ISR
004B            129   
                574   $LIST
                133       $LIST
0A7F            135   
0A7F            136   CSEG
0A7F            137   Init_All:
0A7F            138            ; Configure all the pins for biderectional I/O
0A7F 75AC00     139            mov     P3M1, #0x00
0A82 75AD00     140            mov     P3M2, #0x00
0A85 75B300     141            mov     P1M1, #0x00
0A88 75B400     142            mov     P1M2, #0x00
0A8B 75B100     143            mov     P0M1, #0x00
0A8E 75B200     144            mov     P0M2, #0x00
0A91            145            
0A91 438E10     146            orl     CKCON, #0x10 ; CLK is the input for timer 1
0A94 438780     147            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0A97 759852     148            mov     SCON, #0x52
0A9A 53C4DF     149            anl     T3CON, #0b11011111
0A9D 53890F     150            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0AA0 438920     151            orl     TMOD, #0x20 ; Timer 1 Mode 2
0AA3            152            
0AA3            153            ; Using timer 0 for delay functions.  Initialize here:
0AA3 C28C       154            clr     TR0 ; Stop timer 0
0AA5 438E08     155            orl     CKCON,#0x08 ; CLK is the input for timer 0
0AA8 5389F0     156            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0AAB 438901     157            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0AAE            158            
0AAE            159            ; Initialize and start the ADC:
0AAE            160            
0AAE            161            ; AIN0 is connected to P1.7.  Configure P1.7 as input.
0AAE 43B380     162            orl     P1M1, #0b10000000
0AB1 53B47F     163            anl     P1M2, #0b01111111
0AB4            164            
0AB4            165            ; AINDIDS select if some pins are analog inputs or digital I/O:
0AB4 75F600     166            mov AINDIDS, #0x00 ; Disable all analog inputs
0AB7 43F601     167            orl AINDIDS, #0b00000001 ; Using AIN0
0ABA 43E101     168            orl ADCCON1, #0x01 ; Enable ADC
0ABD            169   
0ABD            170            ; timer 2 ?? 
0ABD 120AF5     171            lcall Timer2_Init
0AC0 D2AF       172            setb EA
0AC2            173   
0AC2            174            
0AC2 22         175            ret
0AC3            176            
0AC3            177   wait_1ms:
0AC3 C28C       178            clr     TR0 ; Stop timer 0
0AC5 C28D       179            clr     TF0 ; Clear overflow flag
0AC7 758CBF     180            mov     TH0, #high(TIMER0_RELOAD_1MS)
0ACA 758A28     181            mov     TL0,#low(TIMER0_RELOAD_1MS)
0ACD D28C       182            setb TR0
0ACF 308DFD     183            jnb     TF0, $ ; Wait for overflow
0AD2 22         184            ret
0AD3            185   
0AD3            186   ; Wait the number of miliseconds in R2
0AD3            187   waitms:
0AD3 120AC3     188            lcall wait_1ms
0AD6 DAFB       189            djnz R2, waitms
0AD8 22         190            ret
0AD9            191   
0AD9            192   ;set cursor before, also might have to change format     
0AD9            193   Display_formated_BCD:  
0AD9            194       ;Display_BCD(bcd+4) 
0AD9            195       ;Display_BCD(bcd+3) 
0AD9 C000       196            push ar0
0ADB A83A       196            mov r0, bcd+2
0ADD 120253     196            lcall ?Display_BCD
0AE0 D000       196            pop ar0 
0AE2 C000       197            push ar0
0AE4 A839       197            mov r0, bcd+1
0AE6 120253     197            lcall ?Display_BCD
0AE9 D000       197            pop ar0 
0AEB C000       198            push ar0
0AED A838       198            mov r0, bcd+0
0AEF 120253     198            lcall ?Display_BCD
0AF2 D000       198            pop ar0  
0AF4 22         199       ret
0AF5            200   
0AF5            201   Timer2_Init:
0AF5 75C800     202            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0AF8 75CDBF     203            mov TH2, #high(TIMER2_RELOAD)
0AFB 75CC28     204            mov TL2, #low(TIMER2_RELOAD)
0AFE            205            ; Set the reload value
0AFE 75C980     206            mov T2MOD, #1000_0000b 
0B01            207            ;orl T2MOD, #0x80 ; Enable timer 2 autoreload this was it before
0B01 75CBBF     208            mov RCMP2H, #high(TIMER2_RELOAD)
0B04 75CA28     209            mov RCMP2L, #low(TIMER2_RELOAD)
0B07            210            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0B07 E4         211            clr a
0B08 F544       212            mov Count1ms+0, a
0B0A F545       213            mov Count1ms+1, a
0B0C 754600     214            mov sec, #0
0B0F C206       215            clr seconds_flag
0B11            216            ; Enable the timer and interrupts
0B11 439B80     217            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0B14 D2CA       218       setb TR2  ; Enable timer 2
0B16 22         219            ret
0B17            220   ;---------------------------------;
0B17            221   ; ISR for timer 2                 ;
0B17            222   ;---------------------------------;
0B17            223   Timer2_ISR:
0B17 C2CF       224            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0B19            225            
0B19            226            ; The two registers used in the ISR must be saved in the stack
0B19 C0E0       227            push acc
0B1B C0D0       228            push psw
0B1D C034       229            push y+0
0B1F C035       230            push y+1
0B21 C036       231            push y+2
0B23 C037       232            push y+3
0B25 C030       233            push x+0
0B27 C031       234            push x+1
0B29 C032       235            push x+2
0B2B C033       236            push x+3
0B2D            237            
0B2D            238            ; Increment the 16-bit one mili second counter
0B2D 0544       239            inc Count1ms+0    ; Increment the low 8-bits first
0B2F E544       240            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0B31 7002       241            jnz SkipCountHigh
0B33 0545       242            inc Count1ms+1
0B35            243   
0B35            244   
0B35            245   SkipCountHigh:
0B35            246   
0B35            247       ;-----------------------------
0B35            248       ; PWM Control – Compute threshold = pwm*10
0B35 C3         249       clr C
0B36 753049     250            mov x+0, #low (pwm % 0x10000) 
0B39 753100     250            mov x+1, #high(pwm % 0x10000) 
0B3C 753200     250            mov x+2, #low (pwm / 0x10000) 
0B3F 753300     250            mov x+3, #high(pwm / 0x10000)       ; Load pwm (0–100) into 32-bit register X
0B42 75340A     251            mov y+0, #low (10 % 0x10000) 
0B45 753500     251            mov y+1, #high(10 % 0x10000) 
0B48 753600     251            mov y+2, #low (10 / 0x10000) 
0B4B 753700     251            mov y+3, #high(10 / 0x10000)        ; Load constant 10 into Y
0B4E 120436     252       lcall mul32            ; Multiply: result in X = pwm*10 (32-bit)
0B51            253       
0B51            254       ; Now compare the 16-bit product (X+0 & X+1) to Count1ms
0B51 C3         255       clr C
0B52 E530       256       mov A, x+0            ; Low byte of product
0B54 9544       257       subb A, Count1ms+0
0B56 E531       258       mov A, x+1            ; High byte of product
0B58 9545       259       subb A, Count1ms+1
0B5A B3         260       cpl C                 ; Invert carry: if no borrow (Count1ms <= pwm*10), C becomes 1.
0B5B 9290       261       mov PWM_OUT, C        
0B5D            262   
0B5D            263       ;-----------------------------
0B5D            264       ; Check if 1000ms have passed to update seconds
0B5D E544       265       mov A, Count1ms+0
0B5F B4E812     266       cjne A, #low(1000), TimeIncrementDone
0B62 E545       267       mov A, Count1ms+1
0B64 B4030D     268       cjne A, #high(1000), TimeIncrementDone
0B67            269       ; 1000ms passed: reset the 1ms counter and update seconds.
0B67 E4         270       clr A
0B68 F544       271       mov Count1ms+0, A
0B6A F545       272       mov Count1ms+1, A
0B6C E54A       273       mov A, seconds
0B6E 3400       274       addc A, #0
0B70 F54A       275       mov seconds, A
0B72 D206       276       setb seconds_flag
0B74            277   
0B74            278   TimeIncrementDone:
0B74 D033       279       pop x+3
0B76 D032       280       pop x+2
0B78 D031       281       pop x+1
0B7A D030       282       pop x+0
0B7C D037       283       pop y+3
0B7E D036       284       pop y+2
0B80 D035       285       pop y+1
0B82 D034       286       pop y+0
0B84 D0D0       287       pop psw
0B86 D0E0       288       pop acc
0B88 32         289       reti
0B89            290   
0B89            291            ;increment second flag 
0B89            292   
0B89            293            ;mov a, seconds
0B89            294            ;add a, #1
0B89            295            ;da A
0B89            296            ;mov seconds, A
0B89            297   
0B89            298   
0B89            299   ;Inc_Done:
0B89            300            ; Check if second has passed
0B89            301   ;        mov a, Count1ms+0
0B89            302   ;        cjne a, #low(1000), Time_increment_done ; Warning: this instruction changes the carry flag!
0B89            303   ;        mov a, Count1ms+1
0B89            304   ;        cjne a, #high(1000), Time_increment_done
0B89            305            
0B89            306            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0B89            307   ;        setb seconds_flag ; Let the main program know a second had passed
0B89            308            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0B89            309            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0B89            310   ;        clr a
0B89            311   ;        mov Count1ms+0, a
0B89            312   ;        mov Count1ms+1, a
0B89            313            ; Increment the time only when state flag is on
0B89            314            ;jnb state, Time_increment_done
0B89            315            
0B89            316   ;        mov a, sec
0B89            317   ;        add a, #0x01
0B89            318   ;        da a
0B89            319   ;        mov sec, a
0B89            320   ;        
0B89            321   ;        cjne a, #0x60, Time_increment_done
0B89            322   
0B89            323                    
0B89            324   
0B89            325   
0B89            326   
0B89            327   
0B89            328   
0B89            329   
0B89            330   
0B89            331   ADC_to_PB:
0B89 C0E0       332            push acc
0B8B 53E8F0     333            anl ADCCON0, #0xF0
0B8E 43E800     334            orl ADCCON0, #0x00 ; Select AIN0
0B91            335            
0B91 C2EF       336            clr ADCF
0B93 D2EE       337            setb ADCS   ; ADC start trigger signal
0B95 30EFFD     338       jnb ADCF, $ ; Wait for conversion complete
0B98            339   
0B98 D204       340            setb RST;PB7
0B9A D203       341            setb NXT;PB6
0B9C D202       342            setb UP;PB5
0B9E D201       343            setb DOWN;PB4
0BA0 D200       344            setb S_S;PB3
0BA2            345            ;setb PB2
0BA2            346            ;setb PB1
0BA2            347            ;setb PB0
0BA2            348            
0BA2            349            ; Check PB7
0BA2            350   ;ADC_to_PB_L7:
0BA2            351   ;        clr c
0BA2            352   ;        mov a, ADCRH
0BA2            353   ;        subb a, #0xf0
0BA2            354   ;        jc ADC_to_PB_L6
0BA2            355   ;        clr RST;PB7
0BA2            356   ;        ret
0BA2            357   ;
0BA2            358   ;        ; Check PB6
0BA2            359   ;ADC_to_PB_L6:
0BA2            360   ;        clr c
0BA2            361   ;        mov a, ADCRH
0BA2            362   ;        subb a, #0xd0
0BA2            363   ;        jc ADC_to_PB_L5
0BA2            364   ;        clr NXT;PB6
0BA2            365   ;        ret
0BA2            366   
0BA2            367            ; Check PB5
0BA2            368   ADC_to_PB_L5:
0BA2 C3         369            clr c
0BA3 E5C3       370            mov a, ADCRH
0BA5 94B0       371            subb a, #0xb0
0BA7 4005       372            jc ADC_to_PB_L4
0BA9 C204       373            clr RST;PB5
0BAB D0E0       374            pop acc
0BAD 22         375            ret
0BAE            376   
0BAE            377            ; Check PB4
0BAE            378   ADC_to_PB_L4:
0BAE C3         379            clr c
0BAF E5C3       380            mov a, ADCRH
0BB1 9490       381            subb a, #0x90
0BB3 4005       382            jc ADC_to_PB_L3
0BB5 C203       383            clr NXT;PB4
0BB7 D0E0       384            pop acc
0BB9 22         385            ret
0BBA            386   
0BBA            387            ; Check PB3
0BBA            388   ADC_to_PB_L3:
0BBA C3         389            clr c
0BBB E5C3       390            mov a, ADCRH
0BBD 9470       391            subb a, #0x70
0BBF 4005       392            jc ADC_to_PB_L2
0BC1 C202       393            clr UP;PB3
0BC3 D0E0       394            pop acc
0BC5 22         395            ret
0BC6            396   
0BC6            397            ; Check PB2
0BC6            398   ADC_to_PB_L2:
0BC6 C3         399            clr c
0BC7 E5C3       400            mov a, ADCRH
0BC9 9450       401            subb a, #0x50
0BCB 4005       402            jc ADC_to_PB_L1
0BCD C201       403            clr DOWN
0BCF D0E0       404            pop acc
0BD1 22         405            ret
0BD2            406   
0BD2            407            ; Check PB1
0BD2            408   ADC_to_PB_L1:
0BD2 C3         409            clr c
0BD3 E5C3       410            mov a, ADCRH
0BD5 9430       411            subb a, #0x30
0BD7 4005       412            jc ADC_to_PB_L0
0BD9 C200       413            clr S_S
0BDB D0E0       414            pop acc
0BDD 22         415            ret
0BDE            416   
0BDE            417            ; Check PB0
0BDE            418   ADC_to_PB_L0:
0BDE C3         419            clr c
0BDF E5C3       420            mov a, ADCRH
0BE1 9410       421            subb a, #0x10
0BE3 4003       422            jc ADC_to_PB_Done
0BE5            423            ;clr PB0
0BE5 D0E0       424            pop acc
0BE7 22         425            ret
0BE8            426            
0BE8            427   ADC_to_PB_Done:
0BE8            428            ; No pusbutton pressed  
0BE8 D0E0       429            pop acc
0BEA 22         430            ret
0BEB            431            
0BEB            432   main:
0BEB 75817F     433            mov sp, #0x7f
0BEE 12052C     434            lcall Temp_Init_All
0BF1 120A7F     435            lcall Init_All
0BF4 12020E     436       lcall LCD_4BIT
0BF7            437       
0BF7 120269     438       lcall state_init ;From State_Machine.inc
0BFA            439       
0BFA            440       ; initial messages in LCD
0BFA C0E0       441            push acc
0BFC 7401       441            mov a, #1
0BFE 14         441            dec a
0BFF 12024E     441            lcall ?Set_Cursor_1 ; Select column and row
0C02 D0E0       441            pop acc
0C04 C083       442            push dph
0C06 C082       442            push dpl
0C08 C0E0       442            push acc
0C0A 90002E     442            mov dptr, #Title
0C0D 120241     442            lcall ?Send_Constant_String
0C10 D0E0       442            pop acc
0C12 D082       442            pop dpl
0C14 D083       442            pop dph
0C16 C0E0       443            push acc
0C18 7401       443            mov a, #1
0C1A 14         443            dec a
0C1B 12024C     443            lcall ?Set_Cursor_2 ; Select column and row
0C1E D0E0       443            pop acc
0C20 C083       444            push dph
0C22 C082       444            push dpl
0C24 C0E0       444            push acc
0C26 90003E     444            mov dptr, #blank
0C29 120241     444            lcall ?Send_Constant_String
0C2C D0E0       444            pop acc
0C2E D082       444            pop dpl
0C30 D083       444            pop dph
0C32            445   
0C32 7AFA       446            mov R2, #250
0C34 120AD3     447            lcall waitms
0C37            448            
0C37            449   Forever:
0C37            450            ; Wait 50 ms between readings
0C37 7A32       451            mov R2, #50
0C39 120AD3     452            lcall waitms
0C3C            453   
0C3C            454            ; output? 
0C3C 300604     455            jnb seconds_flag, no_second
0C3F C206       456            clr seconds_flag
0C41 B295       457            cpl P1.5
0C43            458   
0C43            459   no_second:
0C43            460   
0C43 7A32       461            mov R2, #50
0C45 120AD3     462            lcall waitms
0C48            463   
0C48 020C4B     464            ljmp FSM_select
0C4B            465   
0C4B            466            ;Set_Cursor(2, 11)
0C4B            467            ;mov r0, #80
0C4B            468            ;mov x+0, r0
0C4B            469            ;mov x+1, #0 
0C4B            470            ;mov x+2, #0
0C4B            471            ;mov x+3, #0
0C4B            472            ;lcall hex2bcd
0C4B            473            ;lcall Display_formated_BCD
0C4B            474            
0C4B            475            ;check if reaches forever
0C4B            476            ;Set_Cursor(1, 1)
0C4B            477            ;Send_Constant_String(#forever_message)
0C4B            478            ;mov R2, #250
0C4B            479            ;lcall waitms
0C4B            480            ;ljmp FSM_select
0C4B            481   
0C4B            482   ;no_second:
0C4B            483   ;        ljmp Forever
0C4B            484   
0C4B            485   ;for testing since there's no other fsm right now
0C4B            486   
0C4B            487   
0C4B            488   ;begin select FSM
0C4B            489   FSM_select:
0C4B E53D       490            mov a, selecting_state
0C4D            491   
0C4D            492   select_wait:
0C4D B4004C     493            cjne a, #0, select_soak_time ;checks the state
0C50 C0E0       494            push acc
0C52 7401       494            mov a, #1
0C54 14         494            dec a
0C55 12024E     494            lcall ?Set_Cursor_1 ; Select column and row
0C58 D0E0       494            pop acc
0C5A C083       495            push dph
0C5C C082       495            push dpl
0C5E C0E0       495            push acc
0C60 90004F     495            mov dptr, #swait_message1
0C63 120241     495            lcall ?Send_Constant_String
0C66 D0E0       495            pop acc
0C68 D082       495            pop dpl
0C6A D083       495            pop dph
0C6C C0E0       496            push acc
0C6E 7401       496            mov a, #1
0C70 14         496            dec a
0C71 12024C     496            lcall ?Set_Cursor_2 ; Select column and row
0C74 D0E0       496            pop acc
0C76 C083       497            push dph
0C78 C082       497            push dpl
0C7A C0E0       497            push acc
0C7C 900060     497            mov dptr, #swait_message2
0C7F 120241     497            lcall ?Send_Constant_String
0C82 D0E0       497            pop acc
0C84 D082       497            pop dpl
0C86 D083       497            pop dph
0C88 7AFA       498            mov R2, #250
0C8A 120AD3     499            lcall waitms
0C8D            500       ;lcall ADC_to_PB ;checks for button press
0C8D 120EAB     501       lcall rst_check
0C90 120EB6     502       lcall nxt_check
0C93 120F79     503       lcall s_s_check
0C96 020C37     504       ljmp forever ;i believe 
0C99            505   
0C99            506   select_soak_temp_ah:
0C99 020D21     507            ljmp select_soak_temp
0C9C            508   
0C9C            509   select_soak_time:
0C9C B401FA     510            cjne a, #1, select_soak_temp_ah ;checks the state
0C9F C0E0       511            push acc
0CA1 7401       511            mov a, #1
0CA3 14         511            dec a
0CA4 12024E     511            lcall ?Set_Cursor_1 ; Select column and row
0CA7 D0E0       511            pop acc
0CA9 C083       512            push dph
0CAB C082       512            push dpl
0CAD C0E0       512            push acc
0CAF 900071     512            mov dptr, #sstime_message1
0CB2 120241     512            lcall ?Send_Constant_String
0CB5 D0E0       512            pop acc
0CB7 D082       512            pop dpl
0CB9 D083       512            pop dph
0CBB C0E0       513            push acc
0CBD 7401       513            mov a, #1
0CBF 14         513            dec a
0CC0 12024C     513            lcall ?Set_Cursor_2 ; Select column and row
0CC3 D0E0       513            pop acc
0CC5 C083       514            push dph
0CC7 C082       514            push dpl
0CC9 C0E0       514            push acc
0CCB 900082     514            mov dptr, #sstime_message2
0CCE 120241     514            lcall ?Send_Constant_String
0CD1 D0E0       514            pop acc
0CD3 D082       514            pop dpl
0CD5 D083       514            pop dph
0CD7            515       ;Set_Cursor(2, 11)
0CD7 C005       516       push AR5  ;display the current soak_time
0CD9 AD30       517       mov R5, x
0CDB 853F30     518       mov x+0, soak_time
0CDE 753100     519            mov x+1, #0
0CE1 753200     520            mov x+2, #0
0CE4 753300     521            mov x+3, #0
0CE7 C0E0       522            push acc
0CE9 740B       522            mov a, #11
0CEB 14         522            dec a
0CEC 12024C     522            lcall ?Set_Cursor_2 ; Select column and row
0CEF D0E0       522            pop acc
0CF1            523            ;Send_Constant_String(#its_works)
0CF1 1202BC     524       lcall hex2bcd
0CF4 120AD9     525       lcall Display_formated_BCD
0CF7 8D30       526       mov x, R5
0CF9 D005       527       pop AR5
0CFB            528       ;lcall ADC_to_PB ;checks for button press
0CFB 120EAB     529       lcall rst_check
0CFE C003       530       push AR3 ;set the paramaters for up/down
0D00 C004       531       push AR4
0D02 C005       532       push AR5
0D04 7B3C       533       mov R3, #0x3C ;min value allowed for soak time !check it please
0D06 7C78       534       mov R4, #0x78 ;120  ;max value, !check it please, also is the dec? hex?
0D08 AD3F       535       mov R5, soak_time
0D0A 120EE9     536       lcall up_check
0D0D 120F31     537       lcall down_check
0D10 8D3F       538       mov soak_time, R5
0D12 D005       539       pop AR5
0D14 D004       540       pop AR4
0D16 D003       541       pop AR3  ;am i doing this right?
0D18 120F79     542       lcall s_s_check
0D1B 120EB6     543       lcall nxt_check
0D1E 020C37     544       ljmp forever ;i believe 
0D21            545   
0D21            546   select_soak_temp:
0D21 B40203     547            cjne a, #2, $+6 ;checks the state
0D24 020D2A     548            ljmp $+6
0D27 020DB6     549            ljmp select_reflow_time
0D2A C0E0       550            push acc
0D2C 7401       550            mov a, #1
0D2E 14         550            dec a
0D2F 12024E     550            lcall ?Set_Cursor_1 ; Select column and row
0D32 D0E0       550            pop acc
0D34 C083       551            push dph
0D36 C082       551            push dpl
0D38 C0E0       551            push acc
0D3A 900093     551            mov dptr, #sstemp_message1
0D3D 120241     551            lcall ?Send_Constant_String
0D40 D0E0       551            pop acc
0D42 D082       551            pop dpl
0D44 D083       551            pop dph
0D46 C0E0       552            push acc
0D48 7401       552            mov a, #1
0D4A 14         552            dec a
0D4B 12024C     552            lcall ?Set_Cursor_2 ; Select column and row
0D4E D0E0       552            pop acc
0D50 C083       553            push dph
0D52 C082       553            push dpl
0D54 C0E0       553            push acc
0D56 9000A4     553            mov dptr, #sstemp_message2
0D59 120241     553            lcall ?Send_Constant_String
0D5C D0E0       553            pop acc
0D5E D082       553            pop dpl
0D60 D083       553            pop dph
0D62 C0E0       554            push acc
0D64 740B       554            mov a, #11
0D66 14         554            dec a
0D67 12024C     554            lcall ?Set_Cursor_2 ; Select column and row
0D6A D0E0       554            pop acc
0D6C C005       555       push AR5  ;display current soak temp
0D6E C030       556            push x+0
0D70 C031       556            push x+1
0D72 C032       556            push x+2
0D74 C033       556            push x+3
0D76 854030     557            mov x+0, soak_temp+0
0D79 854131     558            mov x+1, soak_temp+1
0D7C 753200     559            mov x+2, #0
0D7F 753300     560            mov x+3, #0
0D82 1202BC     561       lcall hex2bcd
0D85 120AD9     562       lcall Display_formated_BCD
0D88            563       ;mov x, R5
0D88 D030       564            pop x+0
0D8A D031       564            pop x+1
0D8C D032       564            pop x+2
0D8E D033       564            pop x+3
0D90            565       ;lcall ADC_to_PB ;checks for button press
0D90 120EAB     566       lcall rst_check
0D93 C003       567       push AR3 ;set the paramaters for up/down
0D95 C004       568       push AR4
0D97 C005       569       push AR5
0D99 7B96       570       mov R3, #0x96 ;min value allowed !check it please (150 decimal)
0D9B 7CC8       571       mov R4, #0xC8 ;max value, !check it please, also is the dec? hex? (200 decimal)
0D9D AD40       572       mov R5, soak_temp
0D9F 120EE9     573       lcall up_check
0DA2 120F31     574       lcall down_check
0DA5 8D40       575       mov soak_temp, R5
0DA7 D005       576       pop AR5
0DA9 D004       577       pop AR4
0DAB D003       578       pop AR3  ;am i doing this right?
0DAD 120F79     579       lcall s_s_check
0DB0 120EB6     580       lcall nxt_check
0DB3 020C37     581       ljmp forever ;i believe 
0DB6            582   
0DB6            583   select_reflow_time:
0DB6 B40379     584            cjne a, #3, select_reflow_temp ;checks the state
0DB9 C0E0       585            push acc
0DBB 7401       585            mov a, #1
0DBD 14         585            dec a
0DBE 12024E     585            lcall ?Set_Cursor_1 ; Select column and row
0DC1 D0E0       585            pop acc
0DC3 C083       586            push dph
0DC5 C082       586            push dpl
0DC7 C0E0       586            push acc
0DC9 9000B5     586            mov dptr, #srtime_message1
0DCC 120241     586            lcall ?Send_Constant_String
0DCF D0E0       586            pop acc
0DD1 D082       586            pop dpl
0DD3 D083       586            pop dph
0DD5 C0E0       587            push acc
0DD7 7401       587            mov a, #1
0DD9 14         587            dec a
0DDA 12024C     587            lcall ?Set_Cursor_2 ; Select column and row
0DDD D0E0       587            pop acc
0DDF C083       588            push dph
0DE1 C082       588            push dpl
0DE3 C0E0       588            push acc
0DE5 9000C6     588            mov dptr, #srtime_message2
0DE8 120241     588            lcall ?Send_Constant_String
0DEB D0E0       588            pop acc
0DED D082       588            pop dpl
0DEF D083       588            pop dph
0DF1 C0E0       589            push acc
0DF3 740B       589            mov a, #11
0DF5 14         589            dec a
0DF6 12024C     589            lcall ?Set_Cursor_2 ; Select column and row
0DF9 D0E0       589            pop acc
0DFB C005       590       push AR5  ;display current reflow time
0DFD AD30       591       mov R5, x
0DFF 854130     592       mov x, reflow_time
0E02 1202BC     593       lcall hex2bcd
0E05 120AD9     594       lcall Display_formated_BCD
0E08 8D30       595       mov x, R5
0E0A D005       596       pop AR5
0E0C            597       ;lcall ADC_to_PB ;checks for button press
0E0C 120EAB     598       lcall rst_check
0E0F C003       599       push AR3 ;set the paramaters for up/down
0E11 C004       600       push AR4
0E13 C005       601       push AR5
0E15 7B2D       602       mov R3, #0x2D ;45 min value allowed !check it please
0E17 7C4B       603       mov R4, #0x4B ;75 max value, !check it please, also is the dec? hex?
0E19 AD41       604       mov R5, reflow_time
0E1B 120EE9     605       lcall up_check
0E1E 120F31     606       lcall down_check
0E21 8D41       607       mov reflow_time, R5
0E23 D005       608       pop AR5
0E25 D004       609       pop AR4
0E27 D003       610       pop AR3  ;am i doing this right?
0E29 120F79     611       lcall s_s_check
0E2C 120EB6     612       lcall nxt_check
0E2F 020C37     613       ljmp forever ;i believe 
0E32            614   
0E32            615   select_reflow_temp:
0E32            616            ;shouldn't need to check the state
0E32 C0E0       617            push acc
0E34 7401       617            mov a, #1
0E36 14         617            dec a
0E37 12024E     617            lcall ?Set_Cursor_1 ; Select column and row
0E3A D0E0       617            pop acc
0E3C C083       618            push dph
0E3E C082       618            push dpl
0E40 C0E0       618            push acc
0E42 9000D7     618            mov dptr, #srtemp_message1
0E45 120241     618            lcall ?Send_Constant_String
0E48 D0E0       618            pop acc
0E4A D082       618            pop dpl
0E4C D083       618            pop dph
0E4E C0E0       619            push acc
0E50 7401       619            mov a, #1
0E52 14         619            dec a
0E53 12024C     619            lcall ?Set_Cursor_2 ; Select column and row
0E56 D0E0       619            pop acc
0E58 C083       620            push dph
0E5A C082       620            push dpl
0E5C C0E0       620            push acc
0E5E 9000E8     620            mov dptr, #srtemp_message2
0E61 120241     620            lcall ?Send_Constant_String
0E64 D0E0       620            pop acc
0E66 D082       620            pop dpl
0E68 D083       620            pop dph
0E6A C0E0       621            push acc
0E6C 740B       621            mov a, #11
0E6E 14         621            dec a
0E6F 12024C     621            lcall ?Set_Cursor_2 ; Select column and row
0E72 D0E0       621            pop acc
0E74 C005       622       push AR5  ;display current reflow temp
0E76 AD30       623       mov R5, x
0E78 854230     624       mov x, reflow_temp
0E7B 1202BC     625       lcall hex2bcd
0E7E 120AD9     626       lcall Display_formated_BCD
0E81 8D30       627       mov x, R5
0E83 D005       628       pop AR5
0E85            629       ;lcall ADC_to_PB ;checks for button press
0E85 120EAB     630       lcall rst_check
0E88 C003       631       push AR3  ;set the paramaters for up/down
0E8A C004       632       push AR4
0E8C C005       633       push AR5
0E8E 7BD9       634       mov R3, #0xD9 ;217 DEC ;min value allowed !check it please
0E90 7CFF       635       mov R4, #0xFF ; 255 DEC ;max value, !check it please, also is the dec? hex?
0E92 AD42       636       mov R5, reflow_temp
0E94 120EE9     637       lcall up_check
0E97 120F31     638       lcall down_check
0E9A 8D42       639       mov reflow_temp, R5
0E9C D005       640       pop AR5
0E9E D004       641       pop AR4
0EA0 D003       642       pop AR3  ;am i doing this right?
0EA2 120F79     643       lcall s_s_check
0EA5 120EB6     644       lcall nxt_check
0EA8 020C37     645       ljmp forever ;i believe 
0EAB            646   
0EAB            647   ;maybe make these macros :(
0EAB            648   ;use R3 & R4 & R5 as parameters
0EAB            649   rst_check:
0EAB 120B89     650            lcall ADC_to_PB
0EAE A204       651            mov c, RST
0EB0 5001       652       jnc rst_check_0 ;!could be jc
0EB2 22         653       ret
0EB3            654   rst_check_0:
0EB3 020279     655       ljmp reset_state ;or whatever it's called, wait state of oven fsm
0EB6            656   
0EB6            657   nxt_check:
0EB6 120B89     658            lcall ADC_to_PB
0EB9 A203       659            mov c, NXT
0EBB 5001       660       jnc next_check_1 
0EBD 22         661            ret
0EBE            662   next_check_1: 
0EBE            663       ;load_x(selecting_state)
0EBE            664       ;load_y(4)
0EBE 853D30     665            mov x, selecting_state
0EC1 753100     666            mov x+1, #0
0EC4 753200     667            mov x+2, #0
0EC7 753300     668            mov x+3, #0
0ECA 753404     669            mov y, #0x04
0ECD 753500     670            mov y+1, #0
0ED0 753600     671            mov y+2, #0
0ED3 753700     672            mov y+3, #0
0ED6 1203FC     673       lcall x_eq_y
0ED9 D3         674            setb c
0EDA 200507     675            jb mf, next_check_2
0EDD E53D       676       mov a, selecting_state 
0EDF 3400       677       addc a, #0 ;uh
0EE1 F53D       678       mov selecting_state, a
0EE3 22         679       ret
0EE4            680   next_check_2:
0EE4 C3         681            clr c
0EE5 753D00     682            mov selecting_state, #0 ;can't go above 4 (there are 5 states)
0EE8            683   
0EE8 22         684            ret
0EE9            685   
0EE9            686   up_check: ;R4 max
0EE9 120B89     687            lcall ADC_to_PB
0EEC A202       688            mov c, UP
0EEE 5001       689            jnc up_check_1
0EF0 22         690            ret 
0EF1            691   up_check_1:
0EF1 8C30       692            mov x, R4
0EF3 753100     693            mov x+1, #0
0EF6 753200     694            mov x+2, #0
0EF9 753300     695            mov x+3, #0
0EFC 8D34       696            mov y, R5
0EFE 753500     697            mov y+1, #0
0F01 753600     698            mov y+2, #0
0F04 753700     699            mov y+3, #0
0F07 1203E0     700            lcall x_gt_y ;max > value
0F0A D3         701            setb c
0F0B 300505     702            jnb mf, up_check_2
0F0E ED         703            mov a, R5
0F0F 3400       704            addc a, #0 ;dec? hex?
0F11 FD         705            mov R5, a
0F12 22         706            ret
0F13            707   up_check_2:
0F13 C3         708            clr c
0F14 C0E0       709            push acc
0F16 740B       709            mov a, #11
0F18 14         709            dec a
0F19 12024C     709            lcall ?Set_Cursor_2 ; Select column and row
0F1C D0E0       709            pop acc
0F1E C083       710            push dph
0F20 C082       710            push dpl
0F22 C0E0       710            push acc
0F24 9000F9     710            mov dptr, #too_high_message
0F27 120241     710            lcall ?Send_Constant_String
0F2A D0E0       710            pop acc
0F2C D082       710            pop dpl
0F2E D083       710            pop dph
0F30 22         711            ret
0F31            712   
0F31            713   down_check: ;R3 min
0F31 120B89     714            lcall ADC_to_PB
0F34 A201       715            mov c, DOWN
0F36 5001       716            jnc down_check_1
0F38 22         717            ret
0F39            718   down_check_1:
0F39 8B30       719            mov x, R3
0F3B 753100     720            mov x+1, #0
0F3E 753200     721            mov x+2, #0
0F41 753300     722            mov x+3, #0
0F44 8D34       723            mov y, R5
0F46 753500     724            mov y+1, #0
0F49 753600     725            mov y+2, #0
0F4C 753700     726            mov y+3, #0
0F4F 1203C4     727            lcall x_lt_y ;min < value
0F52 D3         728            setb c
0F53 300505     729            jnb mf, down_check_2
0F56 ED         730            mov a, R5
0F57 9400       731            subb a, #0 ;dec? hex?
0F59 FD         732            mov R5, a
0F5A 22         733            ret
0F5B            734   down_check_2:
0F5B C3         735            clr c
0F5C C0E0       736            push acc
0F5E 740B       736            mov a, #11
0F60 14         736            dec a
0F61 12024C     736            lcall ?Set_Cursor_2 ; Select column and row
0F64 D0E0       736            pop acc
0F66 C083       737            push dph
0F68 C082       737            push dpl
0F6A C0E0       737            push acc
0F6C 900103     737            mov dptr, #too_low_message
0F6F 120241     737            lcall ?Send_Constant_String
0F72 D0E0       737            pop acc
0F74 D082       737            pop dpl
0F76 D083       737            pop dph
0F78 22         738            ret
0F79            739   
0F79            740   s_s_check:
0F79 120B89     741            lcall ADC_to_PB
0F7C A200       742            mov c, S_S
0F7E 5001       743            jnc s_s_check_done ;!could be jb
0F80 22         744            ret
0F81            745   s_s_check_done:
0F81 020761     746            ljmp FSM_Init ;or whatever it's called, 1st state of oven FSM
0F84            747   
0F84            748   END
