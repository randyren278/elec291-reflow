0000              1   
0000              2   
0000              3       ;please work
0000              4   ; do not touch functional except for
0000              5   ; pwm and load_X i think 
0000              6   
0000              7   
0000              8   ;with 5 adc push buttons
0000              9   ;to think about:
0000             10            ;adding another state for when start is pressed so that in forever if it gets sent back to FSM_select
0000             11            ;it will know not to ask for input/go through it
0000             12            ;making the checks into macros
0000             13   
0000             14   ;button functions: rst, next, up, down, start/stop
0000             15   ;display which you're in 
0000             16   ;start-> in the selecting fsm
0000             17   ;stop-> after reset_state in the oven fsm
0000             18   
0000             19   ; 76E003 ADC_Pushbuttons.asm: Reads push buttons using the ADC, AIN0 in P1.7
0000             20   
                 22   $LIST
0000             24   
0000             25   ;  N76E003 pinout:
0000             26   ;                               -------
0000             27   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             28   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             29   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             30   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             31   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             32   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             33   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             34   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             35   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             36   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             37   ;                               -------
0000             38   ;
0000             39   
0000             40   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             41   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             42   TIMER1_RATE         EQU 100      ; 100Hz or 10ms
0000             43   TIMER1_RELOAD       EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 1 input divide to 16 in T2MOD
0000             44   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             45   TIMER2_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             46   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             47   
0000             48   ORG 0x0000
0000 020BD1      49            ljmp main
002B             50   ORG 0x002B
002B 020B17      51            ljmp Timer2_ISR
002E             52   
002E             53   ;                     1234567890123456    <- This helps determine the location of the counter
002E 20206865    54   title:            db '  here we go!  ', 0
     72652077
     6520676F
     21202000
003E 20202020    55   blank:            db '                ', 0
     20202020
     20202020
     20202020
     00
004F 53657420    56   swait_message1:   db 'Set your values ', 0   ;s->select fsm, wait->state
     796F7572
     2076616C
     75657320
     00
0060 50726573    57   swait_message2:   db 'Press next      ', 0
     73206E65
     78742020
     20202020
     00
0071 53656C65    58   sstime_message1:  db 'Select soak time', 0   ;s->soak
     63742073
     6F616B20
     74696D65
     00
0082 536F616B    59   sstime_message2:  db 'Soak time:      ', 0
     2074696D
     653A2020
     20202020
     00
0093 53656C65    60   sstemp_message1:  db 'Select soak temp', 0   ;s->soak
     63742073
     6F616B20
     74656D70
     00
00A4 536F616B    61   sstemp_message2:  db 'Soak temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00B5 53656C65    62   srtime_message1:  db 'Select refl time', 0   ;r->reflow
     63742072
     65666C20
     74696D65
     00
00C6 5265666C    63   srtime_message2:  db 'Refl time:      ', 0
     2074696D
     653A2020
     20202020
     00
00D7 53656C65    64   srtemp_message1:  db 'Select refl temp', 0   ;r->reflow
     63742072
     65666C20
     74656D70
     00
00E8 5265666C    65   srtemp_message2:  db 'Refl temp:      ', 0
     2074656D
     703A2020
     20202020
     00
00F9 6D617821    66   too_high_message: db 'max!     ', 0
     20202020
     2000
0103 6D696E21    67   too_low_message:  db 'min!     ', 0
     20202020
     2000
010D 68656C6C    68   forever_message:  db 'hello please', 0
     6F20706C
     65617365
     00
011A 64696500    69   its_works:        db 'die',0
011E 646F6E65    70   done_message:      db 'done!',0
     2100
0124 73746F70    71   stop_message:      db 'stopped!',0
     70656421
     00
012D             72                                               ;1234567890123456
012D 4F76656E    73   oven_fsm_message_0: db 'Oven State 0!   ',0
     20537461
     74652030
     21202020
     00
013E 4F76656E    74   oven_fsm_message_1: db 'Oven State 1!   ',0
     20537461
     74652031
     21202020
     00
014F 4F76656E    75   oven_fsm_message_2: db 'Oven State 2!   ',0
     20537461
     74652032
     21202020
     00
0160 4F76656E    76   oven_fsm_message_3: db 'Oven State 3!   ',0
     20537461
     74652033
     21202020
     00
0171 4F76656E    77   oven_fsm_message_4: db 'Oven State 4!   ',0
     20537461
     74652034
     21202020
     00
0182 4F76656E    78   oven_fsm_message_5: db 'Oven State 5!   ',0
     20537461
     74652035
     21202020
     00
0193             79   ;                                                   1234567890123456
0193 53657474    80   reset_state_message:   db 'Settings Reset! ', 0 ;for testing
     696E6773
     20526573
     65742120
     00
01A4 73746174    81   state1_message:   db 'state1          ', 0 ;for testing
     65312020
     20202020
     20202020
     00
01B5             82   
01B5             83   cseg
01B5             84   ; These 'equ' must match the hardware wiring
01B5             85   LCD_RS equ P1.3
01B5             86   LCD_E  equ P1.4
01B5             87   LCD_D4 equ P0.0
01B5             88   LCD_D5 equ P0.1
01B5             89   LCD_D6 equ P0.2
01B5             90   LCD_D7 equ P0.3
01B5             91   SOUND_OUT equ P1.5
01B5             92   PWM_OUT    EQU P1.0 ; Logic 1=oven on
01B5             93   
                 96   ;                     1234567890123456    <- This helps determine the location of the counte$LIST
02BC             98   
0000             99   BSEG
0000            100   ; These eight bit variables store the value of the pushbuttons after calling 'ADC_to_PB' below
0000            101   ;PB0: dbit 1 
0000            102   ;PB1: dbit 1     pretty sure left-right is 7-0
0000            103   ;PB2: dbit 1
0000            104   S_S: dbit 1 ;PB3
0001            105   DOWN: dbit 1 ;PB4
0002            106   UP: dbit 1 ;PB5
0003            107   NXT: dbit 1 ;PB6
0004            108   RST: dbit 1 ;PB7
0005            109   mf: dbit 1
0006            110   seconds_flag: dbit 1
0007            111   s_flag: dbit 1 ; set to 1 every time a second has passed
0008            112   oven_flag: dbit 1
0009            113   
0009            114   ;TODO: check if one is enough
0030            115   DSEG at 30H
0030            116   x: ds 4
0034            117   y: ds 4
0038            118   BCD: ds 5
003D            119   selecting_state: ds 1
003E            120   oven_state: ds 1
003F            121   soak_time: ds 1
0040            122   soak_temp: ds 1
0041            123   reflow_time: ds 1
0042            124   reflow_temp: ds 2
0044            125   Count1ms:     ds 2 
0046            126   sec: ds 1
0047            127   temp: ds 1
0048            128   pwm_counter:  ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0049            129   pwm:          ds 1 ; pwm percentage
004A            130   seconds:      ds 1 ; a seconds counter attached to Timer 2 ISR
004B            131   
                574   $LIST
                135       $LIST
0A7F            137   
0A7F            138   CSEG
0A7F            139   Init_All:
0A7F            140            ; Configure all the pins for biderectional I/O
0A7F 75AC00     141            mov     P3M1, #0x00
0A82 75AD00     142            mov     P3M2, #0x00
0A85 75B300     143            mov     P1M1, #0x00
0A88 75B400     144            mov     P1M2, #0x00
0A8B 75B100     145            mov     P0M1, #0x00
0A8E 75B200     146            mov     P0M2, #0x00
0A91            147            
0A91 438E10     148            orl     CKCON, #0x10 ; CLK is the input for timer 1
0A94 438780     149            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0A97 759852     150            mov     SCON, #0x52
0A9A 53C4DF     151            anl     T3CON, #0b11011111
0A9D 53890F     152            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0AA0 438920     153            orl     TMOD, #0x20 ; Timer 1 Mode 2
0AA3            154            
0AA3            155            ; Using timer 0 for delay functions.  Initialize here:
0AA3 C28C       156            clr     TR0 ; Stop timer 0
0AA5 438E08     157            orl     CKCON,#0x08 ; CLK is the input for timer 0
0AA8 5389F0     158            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0AAB 438901     159            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0AAE            160            
0AAE            161            ; Initialize and start the ADC:
0AAE            162            
0AAE            163            ; AIN0 is connected to P1.7.  Configure P1.7 as input.
0AAE 43B380     164            orl     P1M1, #0b10000000
0AB1 53B47F     165            anl     P1M2, #0b01111111
0AB4            166            
0AB4            167            ; AINDIDS select if some pins are analog inputs or digital I/O:
0AB4 75F600     168            mov AINDIDS, #0x00 ; Disable all analog inputs
0AB7 43F601     169            orl AINDIDS, #0b00000001 ; Using AIN0
0ABA 43E101     170            orl ADCCON1, #0x01 ; Enable ADC
0ABD            171   
0ABD            172            ; timer 2 ?? 
0ABD 120AF5     173            lcall Timer2_Init
0AC0 D2AF       174            setb EA
0AC2            175   
0AC2            176            
0AC2 22         177            ret
0AC3            178            
0AC3            179   wait_1ms:
0AC3 C28C       180            clr     TR0 ; Stop timer 0
0AC5 C28D       181            clr     TF0 ; Clear overflow flag
0AC7 758CBF     182            mov     TH0, #high(TIMER0_RELOAD_1MS)
0ACA 758A28     183            mov     TL0,#low(TIMER0_RELOAD_1MS)
0ACD D28C       184            setb TR0
0ACF 308DFD     185            jnb     TF0, $ ; Wait for overflow
0AD2 22         186            ret
0AD3            187   
0AD3            188   ; Wait the number of miliseconds in R2
0AD3            189   waitms:
0AD3 120AC3     190            lcall wait_1ms
0AD6 DAFB       191            djnz R2, waitms
0AD8 22         192            ret
0AD9            193   
0AD9            194   ;set cursor before, also might have to change format     
0AD9            195   Display_formated_BCD:  
0AD9            196       ;Display_BCD(bcd+4) 
0AD9            197       ;Display_BCD(bcd+3) 
0AD9 C000       198            push ar0
0ADB A83A       198            mov r0, bcd+2
0ADD 120253     198            lcall ?Display_BCD
0AE0 D000       198            pop ar0 
0AE2 C000       199            push ar0
0AE4 A839       199            mov r0, bcd+1
0AE6 120253     199            lcall ?Display_BCD
0AE9 D000       199            pop ar0 
0AEB C000       200            push ar0
0AED A838       200            mov r0, bcd+0
0AEF 120253     200            lcall ?Display_BCD
0AF2 D000       200            pop ar0  
0AF4 22         201       ret
0AF5            202   
0AF5            203   Timer2_Init:
0AF5 75C800     204            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0AF8 75CD78     205            mov TH2, #high(TIMER2_RELOAD)
0AFB 75CC90     206            mov TL2, #low(TIMER2_RELOAD)
0AFE            207            ; Set the reload value
0AFE 75C980     208            mov T2MOD, #1000_0000b 
0B01            209            ;orl T2MOD, #0x80 ; Enable timer 2 autoreload this was it before
0B01 75CB78     210            mov RCMP2H, #high(TIMER2_RELOAD)
0B04 75CA90     211            mov RCMP2L, #low(TIMER2_RELOAD)
0B07            212            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0B07 E4         213            clr a
0B08 F544       214            mov Count1ms+0, a
0B0A F545       215            mov Count1ms+1, a
0B0C 754A00     216            mov seconds, #0
0B0F C206       217            clr seconds_flag
0B11            218            ; Enable the timer and interrupts
0B11 439B80     219            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0B14 D2CA       220       setb TR2  ; Enable timer 2
0B16 22         221            ret
0B17            222   ;---------------------------------;
0B17            223   ; ISR for timer 2                 ;
0B17            224   ;---------------------------------;
0B17            225   Timer2_ISR:
0B17 C2CF       226       clr TF2  ; Clear Timer 2 overflow flag
0B19            227   
0B19            228       ; Save registers
0B19 C0E0       229       push acc
0B1B C0D0       230       push psw
0B1D C034       231       push y+0
0B1F C035       232       push y+1
0B21 C036       233       push y+2
0B23 C037       234       push y+3
0B25 C030       235       push x+0
0B27 C031       236       push x+1
0B29 C032       237       push x+2
0B2B C033       238       push x+3
0B2D            239   
0B2D            240       ; Increment the 16-bit one millisecond counter
0B2D 0544       241       inc Count1ms+0
0B2F E544       242       mov a, Count1ms+0
0B31 7002       243       jnz Inc_Done
0B33 0545       244       inc Count1ms+1
0B35            245   
0B35            246   Inc_Done:
0B35            247       ; PWM Control Logic
0B35 0548       248       inc pwm_counter
0B37 C3         249       clr c
0B38 E548       250       mov a, pwm_counter
0B3A 9464       251       subb a, #100
0B3C 4007       252       jc PWM_On  ; If pwm_counter < 100, turn on PWM
0B3E C290       253       clr PWM_OUT  ; Else, turn off PWM
0B40 754800     254       mov pwm_counter, #0  ; Reset pwm_counter
0B43 8002       255       sjmp PWM_Done
0B45            256   
0B45            257   PWM_On:
0B45 D290       258       setb PWM_OUT  ; Turn on PWM
0B47            259   
0B47            260   PWM_Done:
0B47            261       ; Check if 1000 ms (1 second) has passed
0B47 E544       262       mov a, Count1ms+0
0B49 B4640E     263       cjne a, #low(100), Time_increment_done
0B4C E545       264       mov a, Count1ms+1
0B4E B40009     265       cjne a, #high(100), Time_increment_done
0B51            266   
0B51            267       ; Reset the 1-second counter
0B51 E4         268       clr a
0B52 F544       269       mov Count1ms+0, a
0B54 F545       270       mov Count1ms+1, a
0B56            271   
0B56            272       ; Increment the seconds counter
0B56 054A       273       inc seconds
0B58 D206       274       setb seconds_flag
0B5A            275   
0B5A            276   Time_increment_done:
0B5A            277       ; Restore registers
0B5A D033       278       pop x+3
0B5C D032       279       pop x+2
0B5E D031       280       pop x+1
0B60 D030       281       pop x+0
0B62 D037       282       pop y+3
0B64 D036       283       pop y+2
0B66 D035       284       pop y+1
0B68 D034       285       pop y+0
0B6A D0D0       286       pop psw
0B6C D0E0       287       pop acc
0B6E 32         288       reti
0B6F            289   
0B6F            290   
0B6F            291   
0B6F            292   
0B6F            293   
0B6F            294   
0B6F            295   
0B6F            296   ADC_to_PB:
0B6F C0E0       297            push acc
0B71 53E8F0     298            anl ADCCON0, #0xF0
0B74 43E800     299            orl ADCCON0, #0x00 ; Select AIN0
0B77            300            
0B77 C2EF       301            clr ADCF
0B79 D2EE       302            setb ADCS   ; ADC start trigger signal
0B7B 30EFFD     303       jnb ADCF, $ ; Wait for conversion complete
0B7E            304   
0B7E D204       305            setb RST;PB7
0B80 D203       306            setb NXT;PB6
0B82 D202       307            setb UP;PB5
0B84 D201       308            setb DOWN;PB4
0B86 D200       309            setb S_S;PB3
0B88            310            ;setb PB2
0B88            311            ;setb PB1
0B88            312            ;setb PB0
0B88            313            
0B88            314            ; Check PB7
0B88            315   ;ADC_to_PB_L7:
0B88            316   ;        clr c
0B88            317   ;        mov a, ADCRH
0B88            318   ;        subb a, #0xf0
0B88            319   ;        jc ADC_to_PB_L6
0B88            320   ;        clr RST;PB7
0B88            321   ;        ret
0B88            322   ;
0B88            323   ;        ; Check PB6
0B88            324   ;ADC_to_PB_L6:
0B88            325   ;        clr c
0B88            326   ;        mov a, ADCRH
0B88            327   ;        subb a, #0xd0
0B88            328   ;        jc ADC_to_PB_L5
0B88            329   ;        clr NXT;PB6
0B88            330   ;        ret
0B88            331   
0B88            332            ; Check PB5
0B88            333   ADC_to_PB_L5:
0B88 C3         334            clr c
0B89 E5C3       335            mov a, ADCRH
0B8B 94B0       336            subb a, #0xb0
0B8D 4005       337            jc ADC_to_PB_L4
0B8F C204       338            clr RST;PB5
0B91 D0E0       339            pop acc
0B93 22         340            ret
0B94            341   
0B94            342            ; Check PB4
0B94            343   ADC_to_PB_L4:
0B94 C3         344            clr c
0B95 E5C3       345            mov a, ADCRH
0B97 9490       346            subb a, #0x90
0B99 4005       347            jc ADC_to_PB_L3
0B9B C203       348            clr NXT;PB4
0B9D D0E0       349            pop acc
0B9F 22         350            ret
0BA0            351   
0BA0            352            ; Check PB3
0BA0            353   ADC_to_PB_L3:
0BA0 C3         354            clr c
0BA1 E5C3       355            mov a, ADCRH
0BA3 9470       356            subb a, #0x70
0BA5 4005       357            jc ADC_to_PB_L2
0BA7 C202       358            clr UP;PB3
0BA9 D0E0       359            pop acc
0BAB 22         360            ret
0BAC            361   
0BAC            362            ; Check PB2
0BAC            363   ADC_to_PB_L2:
0BAC C3         364            clr c
0BAD E5C3       365            mov a, ADCRH
0BAF 9450       366            subb a, #0x50
0BB1 4005       367            jc ADC_to_PB_L1
0BB3 C201       368            clr DOWN
0BB5 D0E0       369            pop acc
0BB7 22         370            ret
0BB8            371   
0BB8            372            ; Check PB1
0BB8            373   ADC_to_PB_L1:
0BB8 C3         374            clr c
0BB9 E5C3       375            mov a, ADCRH
0BBB 9430       376            subb a, #0x30
0BBD 4005       377            jc ADC_to_PB_L0
0BBF C200       378            clr S_S
0BC1 D0E0       379            pop acc
0BC3 22         380            ret
0BC4            381   
0BC4            382            ; Check PB0
0BC4            383   ADC_to_PB_L0:
0BC4 C3         384            clr c
0BC5 E5C3       385            mov a, ADCRH
0BC7 9410       386            subb a, #0x10
0BC9 4003       387            jc ADC_to_PB_Done
0BCB            388            ;clr PB0
0BCB D0E0       389            pop acc
0BCD 22         390            ret
0BCE            391            
0BCE            392   ADC_to_PB_Done:
0BCE            393            ; No pusbutton pressed  
0BCE D0E0       394            pop acc
0BD0 22         395            ret
0BD1            396            
0BD1            397   main:
0BD1 75817F     398            mov sp, #0x7f
0BD4 12052C     399            lcall Temp_Init_All
0BD7 120A7F     400            lcall Init_All
0BDA 12020E     401       lcall LCD_4BIT
0BDD            402       
0BDD 120269     403       lcall state_init ;From State_Machine.inc
0BE0            404       
0BE0            405       ; initial messages in LCD
0BE0 C0E0       406            push acc
0BE2 7401       406            mov a, #1
0BE4 14         406            dec a
0BE5 12024E     406            lcall ?Set_Cursor_1 ; Select column and row
0BE8 D0E0       406            pop acc
0BEA C083       407            push dph
0BEC C082       407            push dpl
0BEE C0E0       407            push acc
0BF0 90002E     407            mov dptr, #Title
0BF3 120241     407            lcall ?Send_Constant_String
0BF6 D0E0       407            pop acc
0BF8 D082       407            pop dpl
0BFA D083       407            pop dph
0BFC C0E0       408            push acc
0BFE 7401       408            mov a, #1
0C00 14         408            dec a
0C01 12024C     408            lcall ?Set_Cursor_2 ; Select column and row
0C04 D0E0       408            pop acc
0C06 C083       409            push dph
0C08 C082       409            push dpl
0C0A C0E0       409            push acc
0C0C 90003E     409            mov dptr, #blank
0C0F 120241     409            lcall ?Send_Constant_String
0C12 D0E0       409            pop acc
0C14 D082       409            pop dpl
0C16 D083       409            pop dph
0C18            410   
0C18 7AFA       411            mov R2, #250
0C1A 120AD3     412            lcall waitms
0C1D            413            
0C1D            414   Forever:
0C1D            415            ; Wait 50 ms between readings
0C1D 7A32       416            mov R2, #50
0C1F 120AD3     417            lcall waitms
0C22            418   
0C22            419            ; output? 
0C22 300604     420            jnb seconds_flag, no_second
0C25 C206       421            clr seconds_flag
0C27 B295       422            cpl P1.5
0C29            423   
0C29            424   no_second:
0C29            425   
0C29 7A32       426            mov R2, #50
0C2B 120AD3     427            lcall waitms
0C2E            428   
0C2E 020C31     429            ljmp FSM_select
0C31            430   
0C31            431            ;Set_Cursor(2, 11)
0C31            432            ;mov r0, #80
0C31            433            ;mov x+0, r0
0C31            434            ;mov x+1, #0 
0C31            435            ;mov x+2, #0
0C31            436            ;mov x+3, #0
0C31            437            ;lcall hex2bcd
0C31            438            ;lcall Display_formated_BCD
0C31            439            
0C31            440            ;check if reaches forever
0C31            441            ;Set_Cursor(1, 1)
0C31            442            ;Send_Constant_String(#forever_message)
0C31            443            ;mov R2, #250
0C31            444            ;lcall waitms
0C31            445            ;ljmp FSM_select
0C31            446   
0C31            447   ;no_second:
0C31            448   ;        ljmp Forever
0C31            449   
0C31            450   ;for testing since there's no other fsm right now
0C31            451   
0C31            452   
0C31            453   ;begin select FSM
0C31            454   FSM_select:
0C31 E53D       455            mov a, selecting_state
0C33            456   
0C33            457   select_wait:
0C33 B4004C     458            cjne a, #0, select_soak_time ;checks the state
0C36 C0E0       459            push acc
0C38 7401       459            mov a, #1
0C3A 14         459            dec a
0C3B 12024E     459            lcall ?Set_Cursor_1 ; Select column and row
0C3E D0E0       459            pop acc
0C40 C083       460            push dph
0C42 C082       460            push dpl
0C44 C0E0       460            push acc
0C46 90004F     460            mov dptr, #swait_message1
0C49 120241     460            lcall ?Send_Constant_String
0C4C D0E0       460            pop acc
0C4E D082       460            pop dpl
0C50 D083       460            pop dph
0C52 C0E0       461            push acc
0C54 7401       461            mov a, #1
0C56 14         461            dec a
0C57 12024C     461            lcall ?Set_Cursor_2 ; Select column and row
0C5A D0E0       461            pop acc
0C5C C083       462            push dph
0C5E C082       462            push dpl
0C60 C0E0       462            push acc
0C62 900060     462            mov dptr, #swait_message2
0C65 120241     462            lcall ?Send_Constant_String
0C68 D0E0       462            pop acc
0C6A D082       462            pop dpl
0C6C D083       462            pop dph
0C6E 7AFA       463            mov R2, #250
0C70 120AD3     464            lcall waitms
0C73            465       ;lcall ADC_to_PB ;checks for button press
0C73 120E91     466       lcall rst_check
0C76 120E9C     467       lcall nxt_check
0C79 120F5F     468       lcall s_s_check
0C7C 020C1D     469       ljmp forever ;i believe 
0C7F            470   
0C7F            471   select_soak_temp_ah:
0C7F 020D07     472            ljmp select_soak_temp
0C82            473   
0C82            474   select_soak_time:
0C82 B401FA     475            cjne a, #1, select_soak_temp_ah ;checks the state
0C85 C0E0       476            push acc
0C87 7401       476            mov a, #1
0C89 14         476            dec a
0C8A 12024E     476            lcall ?Set_Cursor_1 ; Select column and row
0C8D D0E0       476            pop acc
0C8F C083       477            push dph
0C91 C082       477            push dpl
0C93 C0E0       477            push acc
0C95 900071     477            mov dptr, #sstime_message1
0C98 120241     477            lcall ?Send_Constant_String
0C9B D0E0       477            pop acc
0C9D D082       477            pop dpl
0C9F D083       477            pop dph
0CA1 C0E0       478            push acc
0CA3 7401       478            mov a, #1
0CA5 14         478            dec a
0CA6 12024C     478            lcall ?Set_Cursor_2 ; Select column and row
0CA9 D0E0       478            pop acc
0CAB C083       479            push dph
0CAD C082       479            push dpl
0CAF C0E0       479            push acc
0CB1 900082     479            mov dptr, #sstime_message2
0CB4 120241     479            lcall ?Send_Constant_String
0CB7 D0E0       479            pop acc
0CB9 D082       479            pop dpl
0CBB D083       479            pop dph
0CBD            480       ;Set_Cursor(2, 11)
0CBD C005       481       push AR5  ;display the current soak_time
0CBF AD30       482       mov R5, x
0CC1 853F30     483       mov x+0, soak_time
0CC4 753100     484            mov x+1, #0
0CC7 753200     485            mov x+2, #0
0CCA 753300     486            mov x+3, #0
0CCD C0E0       487            push acc
0CCF 740B       487            mov a, #11
0CD1 14         487            dec a
0CD2 12024C     487            lcall ?Set_Cursor_2 ; Select column and row
0CD5 D0E0       487            pop acc
0CD7            488            ;Send_Constant_String(#its_works)
0CD7 1202BC     489       lcall hex2bcd
0CDA 120AD9     490       lcall Display_formated_BCD
0CDD 8D30       491       mov x, R5
0CDF D005       492       pop AR5
0CE1            493       ;lcall ADC_to_PB ;checks for button press
0CE1 120E91     494       lcall rst_check
0CE4 C003       495       push AR3 ;set the paramaters for up/down
0CE6 C004       496       push AR4
0CE8 C005       497       push AR5
0CEA 7B3C       498       mov R3, #0x3C ;min value allowed for soak time !check it please
0CEC 7C78       499       mov R4, #0x78 ;120  ;max value, !check it please, also is the dec? hex?
0CEE AD3F       500       mov R5, soak_time
0CF0 120ECF     501       lcall up_check
0CF3 120F17     502       lcall down_check
0CF6 8D3F       503       mov soak_time, R5
0CF8 D005       504       pop AR5
0CFA D004       505       pop AR4
0CFC D003       506       pop AR3  ;am i doing this right?
0CFE 120F5F     507       lcall s_s_check
0D01 120E9C     508       lcall nxt_check
0D04 020C1D     509       ljmp forever ;i believe 
0D07            510   
0D07            511   select_soak_temp:
0D07 B40203     512            cjne a, #2, $+6 ;checks the state
0D0A 020D10     513            ljmp $+6
0D0D 020D9C     514            ljmp select_reflow_time
0D10 C0E0       515            push acc
0D12 7401       515            mov a, #1
0D14 14         515            dec a
0D15 12024E     515            lcall ?Set_Cursor_1 ; Select column and row
0D18 D0E0       515            pop acc
0D1A C083       516            push dph
0D1C C082       516            push dpl
0D1E C0E0       516            push acc
0D20 900093     516            mov dptr, #sstemp_message1
0D23 120241     516            lcall ?Send_Constant_String
0D26 D0E0       516            pop acc
0D28 D082       516            pop dpl
0D2A D083       516            pop dph
0D2C C0E0       517            push acc
0D2E 7401       517            mov a, #1
0D30 14         517            dec a
0D31 12024C     517            lcall ?Set_Cursor_2 ; Select column and row
0D34 D0E0       517            pop acc
0D36 C083       518            push dph
0D38 C082       518            push dpl
0D3A C0E0       518            push acc
0D3C 9000A4     518            mov dptr, #sstemp_message2
0D3F 120241     518            lcall ?Send_Constant_String
0D42 D0E0       518            pop acc
0D44 D082       518            pop dpl
0D46 D083       518            pop dph
0D48 C0E0       519            push acc
0D4A 740B       519            mov a, #11
0D4C 14         519            dec a
0D4D 12024C     519            lcall ?Set_Cursor_2 ; Select column and row
0D50 D0E0       519            pop acc
0D52 C005       520       push AR5  ;display current soak temp
0D54 C030       521            push x+0
0D56 C031       521            push x+1
0D58 C032       521            push x+2
0D5A C033       521            push x+3
0D5C 854030     522            mov x+0, soak_temp
0D5F 753100     523            mov x+1, #0
0D62 753200     524            mov x+2, #0
0D65 753300     525            mov x+3, #0
0D68 1202BC     526       lcall hex2bcd
0D6B 120AD9     527       lcall Display_formated_BCD
0D6E            528       ;mov x, R5
0D6E D030       529            pop x+0
0D70 D031       529            pop x+1
0D72 D032       529            pop x+2
0D74 D033       529            pop x+3
0D76            530       ;lcall ADC_to_PB ;checks for button press
0D76 120E91     531       lcall rst_check
0D79 C003       532       push AR3 ;set the paramaters for up/down
0D7B C004       533       push AR4
0D7D C005       534       push AR5
0D7F 7B96       535       mov R3, #0x96 ;min value allowed !check it please (150 decimal)
0D81 7CC8       536       mov R4, #0xC8 ;max value, !check it please, also is the dec? hex? (200 decimal)
0D83 AD40       537       mov R5, soak_temp
0D85 120ECF     538       lcall up_check
0D88 120F17     539       lcall down_check
0D8B 8D40       540       mov soak_temp, R5
0D8D D005       541       pop AR5
0D8F D004       542       pop AR4
0D91 D003       543       pop AR3  ;am i doing this right?
0D93 120F5F     544       lcall s_s_check
0D96 120E9C     545       lcall nxt_check
0D99 020C1D     546       ljmp forever ;i believe 
0D9C            547   
0D9C            548   select_reflow_time:
0D9C B40379     549            cjne a, #3, select_reflow_temp ;checks the state
0D9F C0E0       550            push acc
0DA1 7401       550            mov a, #1
0DA3 14         550            dec a
0DA4 12024E     550            lcall ?Set_Cursor_1 ; Select column and row
0DA7 D0E0       550            pop acc
0DA9 C083       551            push dph
0DAB C082       551            push dpl
0DAD C0E0       551            push acc
0DAF 9000B5     551            mov dptr, #srtime_message1
0DB2 120241     551            lcall ?Send_Constant_String
0DB5 D0E0       551            pop acc
0DB7 D082       551            pop dpl
0DB9 D083       551            pop dph
0DBB C0E0       552            push acc
0DBD 7401       552            mov a, #1
0DBF 14         552            dec a
0DC0 12024C     552            lcall ?Set_Cursor_2 ; Select column and row
0DC3 D0E0       552            pop acc
0DC5 C083       553            push dph
0DC7 C082       553            push dpl
0DC9 C0E0       553            push acc
0DCB 9000C6     553            mov dptr, #srtime_message2
0DCE 120241     553            lcall ?Send_Constant_String
0DD1 D0E0       553            pop acc
0DD3 D082       553            pop dpl
0DD5 D083       553            pop dph
0DD7 C0E0       554            push acc
0DD9 740B       554            mov a, #11
0DDB 14         554            dec a
0DDC 12024C     554            lcall ?Set_Cursor_2 ; Select column and row
0DDF D0E0       554            pop acc
0DE1 C005       555       push AR5  ;display current reflow time
0DE3 AD30       556       mov R5, x
0DE5 854130     557       mov x, reflow_time
0DE8 1202BC     558       lcall hex2bcd
0DEB 120AD9     559       lcall Display_formated_BCD
0DEE 8D30       560       mov x, R5
0DF0 D005       561       pop AR5
0DF2            562       ;lcall ADC_to_PB ;checks for button press
0DF2 120E91     563       lcall rst_check
0DF5 C003       564       push AR3 ;set the paramaters for up/down
0DF7 C004       565       push AR4
0DF9 C005       566       push AR5
0DFB 7B00       567       mov R3, #0x00 ;45 min value allowed !check it please
0DFD 7C2D       568       mov R4, #0x2D ;75 max value, !check it please, also is the dec? hex?
0DFF AD41       569       mov R5, reflow_time
0E01 120ECF     570       lcall up_check
0E04 120F17     571       lcall down_check
0E07 8D41       572       mov reflow_time, R5
0E09 D005       573       pop AR5
0E0B D004       574       pop AR4
0E0D D003       575       pop AR3  ;am i doing this right?
0E0F 120F5F     576       lcall s_s_check
0E12 120E9C     577       lcall nxt_check
0E15 020C1D     578       ljmp forever ;i believe 
0E18            579   
0E18            580   select_reflow_temp:
0E18            581            ;shouldn't need to check the state
0E18 C0E0       582            push acc
0E1A 7401       582            mov a, #1
0E1C 14         582            dec a
0E1D 12024E     582            lcall ?Set_Cursor_1 ; Select column and row
0E20 D0E0       582            pop acc
0E22 C083       583            push dph
0E24 C082       583            push dpl
0E26 C0E0       583            push acc
0E28 9000D7     583            mov dptr, #srtemp_message1
0E2B 120241     583            lcall ?Send_Constant_String
0E2E D0E0       583            pop acc
0E30 D082       583            pop dpl
0E32 D083       583            pop dph
0E34 C0E0       584            push acc
0E36 7401       584            mov a, #1
0E38 14         584            dec a
0E39 12024C     584            lcall ?Set_Cursor_2 ; Select column and row
0E3C D0E0       584            pop acc
0E3E C083       585            push dph
0E40 C082       585            push dpl
0E42 C0E0       585            push acc
0E44 9000E8     585            mov dptr, #srtemp_message2
0E47 120241     585            lcall ?Send_Constant_String
0E4A D0E0       585            pop acc
0E4C D082       585            pop dpl
0E4E D083       585            pop dph
0E50 C0E0       586            push acc
0E52 740B       586            mov a, #11
0E54 14         586            dec a
0E55 12024C     586            lcall ?Set_Cursor_2 ; Select column and row
0E58 D0E0       586            pop acc
0E5A C005       587       push AR5  ;display current reflow temp
0E5C AD30       588       mov R5, x
0E5E 854230     589       mov x, reflow_temp
0E61 1202BC     590       lcall hex2bcd
0E64 120AD9     591       lcall Display_formated_BCD
0E67 8D30       592       mov x, R5
0E69 D005       593       pop AR5
0E6B            594       ;lcall ADC_to_PB ;checks for button press
0E6B 120E91     595       lcall rst_check
0E6E C003       596       push AR3  ;set the paramaters for up/down
0E70 C004       597       push AR4
0E72 C005       598       push AR5
0E74 7BD9       599       mov R3, #0xD9 ;217 DEC ;min value allowed !check it please
0E76 7CF0       600       mov R4, #0xF0 ; 255 DEC ;max value, !check it please, also is the dec? hex?
0E78 AD42       601       mov R5, reflow_temp
0E7A 120ECF     602       lcall up_check
0E7D 120F17     603       lcall down_check
0E80 8D42       604       mov reflow_temp, R5
0E82 D005       605       pop AR5
0E84 D004       606       pop AR4
0E86 D003       607       pop AR3  ;am i doing this right?
0E88 120F5F     608       lcall s_s_check
0E8B 120E9C     609       lcall nxt_check
0E8E 020C1D     610       ljmp forever ;i believe 
0E91            611   
0E91            612   ;maybe make these macros :(
0E91            613   ;use R3 & R4 & R5 as parameters
0E91            614   rst_check:
0E91 120B6F     615            lcall ADC_to_PB
0E94 A204       616            mov c, RST
0E96 5001       617       jnc rst_check_0 ;!could be jc
0E98 22         618       ret
0E99            619   rst_check_0:
0E99 020279     620       ljmp reset_state ;or whatever it's called, wait state of oven fsm
0E9C            621   
0E9C            622   nxt_check:
0E9C 120B6F     623            lcall ADC_to_PB
0E9F A203       624            mov c, NXT
0EA1 5001       625       jnc next_check_1 
0EA3 22         626            ret
0EA4            627   next_check_1: 
0EA4            628       ;load_x(selecting_state)
0EA4            629       ;load_y(4)
0EA4 853D30     630            mov x, selecting_state
0EA7 753100     631            mov x+1, #0
0EAA 753200     632            mov x+2, #0
0EAD 753300     633            mov x+3, #0
0EB0 753404     634            mov y, #0x04
0EB3 753500     635            mov y+1, #0
0EB6 753600     636            mov y+2, #0
0EB9 753700     637            mov y+3, #0
0EBC 1203FC     638       lcall x_eq_y
0EBF D3         639            setb c
0EC0 200507     640            jb mf, next_check_2
0EC3 E53D       641       mov a, selecting_state 
0EC5 3400       642       addc a, #0 ;uh
0EC7 F53D       643       mov selecting_state, a
0EC9 22         644       ret
0ECA            645   next_check_2:
0ECA C3         646            clr c
0ECB 753D00     647            mov selecting_state, #0 ;can't go above 4 (there are 5 states)
0ECE            648   
0ECE 22         649            ret
0ECF            650   
0ECF            651   up_check: ;R4 max
0ECF 120B6F     652            lcall ADC_to_PB
0ED2 A202       653            mov c, UP
0ED4 5001       654            jnc up_check_1
0ED6 22         655            ret 
0ED7            656   up_check_1:
0ED7 8C30       657            mov x, R4
0ED9 753100     658            mov x+1, #0
0EDC 753200     659            mov x+2, #0
0EDF 753300     660            mov x+3, #0
0EE2 8D34       661            mov y, R5
0EE4 753500     662            mov y+1, #0
0EE7 753600     663            mov y+2, #0
0EEA 753700     664            mov y+3, #0
0EED 1203E0     665            lcall x_gt_y ;max > value
0EF0 D3         666            setb c
0EF1 300505     667            jnb mf, up_check_2
0EF4 ED         668            mov a, R5
0EF5 3400       669            addc a, #0 ;dec? hex?
0EF7 FD         670            mov R5, a
0EF8 22         671            ret
0EF9            672   up_check_2:
0EF9 C3         673            clr c
0EFA C0E0       674            push acc
0EFC 740B       674            mov a, #11
0EFE 14         674            dec a
0EFF 12024C     674            lcall ?Set_Cursor_2 ; Select column and row
0F02 D0E0       674            pop acc
0F04 C083       675            push dph
0F06 C082       675            push dpl
0F08 C0E0       675            push acc
0F0A 9000F9     675            mov dptr, #too_high_message
0F0D 120241     675            lcall ?Send_Constant_String
0F10 D0E0       675            pop acc
0F12 D082       675            pop dpl
0F14 D083       675            pop dph
0F16 22         676            ret
0F17            677   
0F17            678   down_check: ;R3 min
0F17 120B6F     679            lcall ADC_to_PB
0F1A A201       680            mov c, DOWN
0F1C 5001       681            jnc down_check_1
0F1E 22         682            ret
0F1F            683   down_check_1:
0F1F 8B30       684            mov x, R3
0F21 753100     685            mov x+1, #0
0F24 753200     686            mov x+2, #0
0F27 753300     687            mov x+3, #0
0F2A 8D34       688            mov y, R5
0F2C 753500     689            mov y+1, #0
0F2F 753600     690            mov y+2, #0
0F32 753700     691            mov y+3, #0
0F35 1203C4     692            lcall x_lt_y ;min < value
0F38 D3         693            setb c
0F39 300505     694            jnb mf, down_check_2
0F3C ED         695            mov a, R5
0F3D 9400       696            subb a, #0 ;dec? hex?
0F3F FD         697            mov R5, a
0F40 22         698            ret
0F41            699   down_check_2:
0F41 C3         700            clr c
0F42 C0E0       701            push acc
0F44 740B       701            mov a, #11
0F46 14         701            dec a
0F47 12024C     701            lcall ?Set_Cursor_2 ; Select column and row
0F4A D0E0       701            pop acc
0F4C C083       702            push dph
0F4E C082       702            push dpl
0F50 C0E0       702            push acc
0F52 900103     702            mov dptr, #too_low_message
0F55 120241     702            lcall ?Send_Constant_String
0F58 D0E0       702            pop acc
0F5A D082       702            pop dpl
0F5C D083       702            pop dph
0F5E 22         703            ret
0F5F            704   
0F5F            705   s_s_check:
0F5F 120B6F     706            lcall ADC_to_PB
0F62 A200       707            mov c, S_S
0F64 5001       708            jnc s_s_check_done ;!could be jb
0F66 22         709            ret
0F67            710   s_s_check_done:
0F67 020761     711            ljmp FSM_Init ;or whatever it's called, 1st state of oven FSM
0F6A            712   
0F6A            713   END
